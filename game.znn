
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "projectile.znn";
export import "table.znn";
export import "glyph.znn";
export import "game_object_attributes.znn";
import "std/time.znn";
export import "level_generator.znn";
import "std/hash_map.znn";

export struct Tile {
  Glyph glyph;
};

export Tile copy(Tile*) = default;

export struct Level {
  string name;
  table<Tile> tiles;
};

export Level(string name, vec2 size) {
  const tiles = table(size, Tile(Glyph(".", color(80, 80, 80))));
  return Level::Level(name, move(tiles));
}

export Tile*? getTile(Level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}

export struct GameObject {
  vec2d pos;
  int? timeout;
  int lastMovement;
  GameObjectAttributes attributes;
};

vec2d? getRebound(GameObject* o1, GameObject* o2) {
  if (!!o1->attributes.box && !!o2->attributes.box)
    return getRebound(&*o1->attributes.box, &*o2->attributes.box, o1->pos - o2->pos);
  return null;
}

export bool advance(GameObject mutable* c, Game* g, double amount, double angle) {
  return c->advance(g, vec2d(sin(angle), cos(angle)) * amount);
}

export bool advance(GameObject mutable* c, Game* g, vec2d dir) {
  c->pos += dir;
  if (c->attributes.creature)
    c->lastMovement = current_time_milli();
  mutable ret = false;
  for (it : g->objects)
    if (&*it != c)
      if (const v = getRebound(c, &*it)) {
        c->pos -= *v;
        ret = true;
      }
  return ret;
}

export struct Game {
  Level level;
  vector<GameObject> objects;
};

export void advance(Game mutable* g, double timeDiff) {
  mutable toRemove = vector<int>();
  mutable toAdd = vector<GameObject>();
  const curTime = current_time_milli();
  for (it : g->objects) {
    if (!!it->timeout && *it->timeout < curTime)
      toRemove.push_back(it.index);
    else if (it->attributes.projectile) {
      const prevPos = it->pos;
      if (it->advance(g, it->attributes.projectile->dir * timeDiff)) {
        toRemove.push_back(it.index);
        toAdd.push_back(getEffect(prevPos, curTime + 500, Glyph("*", color(255, 100, 0))));
      }
    }
  }
  for (i = toRemove.size() - 1; i >= 0; --i)
    g->objects.remove(toRemove[i]);
  while (!toAdd.empty())
    g->objects.push_back(toAdd.pop_back());
}

export void spawnProjectile(Game mutable *g, GameObject* o, double dir, Glyph glyph) {
  const vdir = vec2d(sin(dir), cos(dir));
  g->objects.push_back(GameObject(
      o->pos + vdir * 1.0,
      null,
      0,
      GameObjectAttributes(
        move(glyph),
        BoundingBox(0.4),
        null,
        Projectile(vdir * 10.0),
        false
      )
  ));
}

GameObject getEffect(vec2d pos, int timeout, Glyph glyph) {
  return GameObject(
      pos,
      timeout,
      0,
      GameObjectAttributes(
        move(glyph),
        null,
        null,
        null,
        false
      )
  );
}

export GameObject* getPlayer(Game* g) {
  return &g->objects[0];
}

export GameObject mutable* getPlayer(Game mutable* g) {
  return &g->objects[0];
}

vector<GameObject> getObjects(vec2 levelSize, LevelGenerator* generator,
    hash_map<string, GameObjectAttributes>* mapping) {
  mutable ret = vector<GameObject>();
  const playerPos = levelSize.as_double() / 2.0;
  ret.push_back(GameObject(playerPos, null, 0, mapping->get(&"player")->copy()));
  const roomSize = 3;
  const roomCenter = playerPos - vec2d(roomSize + 3.0, 0.0);
  ret.push_back(GameObject(roomCenter, null, 0, mapping->get(&"enemy")->copy()));
  const levelTable = *generator->generate(levelSize);
  for (v : levelTable.bounds())
    for (token : levelTable[*v])
      if (const attr = mapping->get_maybe(&*token)) {
        ret.push_back(GameObject(v->as_double(), null, 0, (*attr)->copy()));
    }
  return move(ret);
}

export Game(LevelGenerator* generator, hash_map<string, GameObjectAttributes>* mapping) {
  const size = vec2(30, 30);
  return Game::Game(Level("Level 1", size), getObjects(size, generator, mapping));
}

