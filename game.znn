
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "table.znn";

export struct tile {
  char symbol;
};

export tile copy(tile*) = default;

export struct level {
  string name;
  table<tile> tiles;
};

export level(string name, vec2 size) {
  const tiles = table(size, tile('.'));
  return level::level(name, move(tiles));
}

export tile*? get_tile(level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}


export struct bounding_box {
  double size;
};

vec2d? get_rebound(bounding_box* b, bounding_box* other, vec2d p) {
  const l = p.length_d();
  const min_dist = (b->size + other->size) / 2;
  if (l < min_dist) {
    if (l < 0.001)
      return vec2d(min_dist, 0);
    return p-p / l * min_dist;
  }
  return null;
}

export bounding_box implicit_copy(bounding_box*) = default;

export struct game_object {
  vec2d pos;
  double dir;
  char symbol;
  color color;
  bounding_box box;
  creature? creature;
};

vec2d? get_rebound(game_object* o1, game_object* o2) {
  return get_rebound(&o1->box, &o2->box, o1->pos - o2->pos);
}

export void advance(game_object mutable* c, game* g, double amount, double angle) {
  const d = vec2d(sin(c->dir + angle), cos(c->dir + angle)) * amount;
  c->pos += d;
  for (it : g->objects)
    if (&*it != c)
      if (const v = get_rebound(c, &*it))
        c->pos -= *v;
}

export struct game {
  level level;
  vector<game_object> objects;
};

export game_object* get_player(game* g) {
  return &g->objects[0];
}

export game_object mutable* get_player(game mutable* g) {
  return &g->objects[0];
}

vector<game_object> get_objects() {
  mutable ret = vector<game_object>();
  const player_pos = vec2d(150, 150);
  ret.push_back(game_object(player_pos, 0.0, '@', color(255, 255, 255), bounding_box(1.0), creature()));
  const roomSize = 3;
  const room_center = player_pos - vec2d(roomSize + 3.0, 0.0);
  ret.push_back(game_object(room_center, 0.0, '&', color(255, 0, 0), bounding_box(1.0), creature()));
  for (i : range(-roomSize, roomSize + 1)) {
    const c = color(210, 105, 30);
    const box = bounding_box(1.0);
    if (i != 0)
      ret.push_back(game_object(vec2d(room_center.x + i, room_center.y - roomSize), 0.0, '#', c, box, null));
    ret.push_back(game_object(vec2d(room_center.x + i, room_center.y + roomSize), 0.0, '#', c, box, null));
    ret.push_back(game_object(vec2d(room_center.x - roomSize, room_center.y + i), 0.0, '#', c, box, null));
    ret.push_back(game_object(vec2d(room_center.x + roomSize, room_center.y + i), 0.0, '#', c, box, null));
  }
  return move(ret);
}

export game() {
  return game::game(level("Level 1", vec2(300, 300)), get_objects());
}

