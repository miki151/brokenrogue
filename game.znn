
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "projectile.znn";
export import "table.znn";
export import "glyph.znn";
import "std/time.znn";

export struct Tile {
  Glyph glyph;
};

export Tile copy(Tile*) = default;

export struct Level {
  string name;
  table<Tile> tiles;
};

export Level(string name, vec2 size) {
  const tiles = table(size, Tile(Glyph('.', color(80, 80, 80))));
  return Level::Level(name, move(tiles));
}

export Tile*? getTile(Level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}


export struct BoundingBox {
  double size;
};

vec2d? getRebound(BoundingBox* b, BoundingBox* other, vec2d p) {
  const l = p.length_d();
  const min_dist = (b->size + other->size) / 2;
  if (l < min_dist) {
    if (l < 0.001)
      return vec2d(min_dist, 0);
    return p-p / l * min_dist;
  }
  return null;
}

export BoundingBox implicit_copy(BoundingBox*) = default;

export struct GameObject {
  vec2d pos;
  Glyph glyph;
  BoundingBox? box;
  Creature? creature;
  Projectile? projectile;
  bool blocksVision;
  int? timeout;
};

vec2d? getRebound(GameObject* o1, GameObject* o2) {
  if (!!o1->box && !!o2->box)
    return getRebound(&*o1->box, &*o2->box, o1->pos - o2->pos);
  return null;
}

export bool advance(GameObject mutable* c, Game* g, double amount, double angle) {
  return c->advance(g, vec2d(sin(angle), cos(angle)) * amount);
}

export bool advance(GameObject mutable* c, Game* g, vec2d dir) {
  c->pos += dir;
  if (c->creature)
    c->creature->lastMovement = current_time_milli();
  mutable ret = false;
  for (it : g->objects)
    if (&*it != c)
      if (const v = getRebound(c, &*it)) {
        c->pos -= *v;
        ret = true;
      }
  return ret;
}

export struct Game {
  Level level;
  vector<GameObject> objects;
};

export void advance(Game mutable* g, double timeDiff) {
  mutable toRemove = vector<int>();
  mutable toAdd = vector<GameObject>();
  const curTime = current_time_milli();
  for (it : g->objects) {
    if (!!it->timeout && *it->timeout < curTime)
      toRemove.push_back(it.index);
    else if (it->projectile) {
      const prevPos = it->pos;
      if (it->advance(g, it->projectile->dir * timeDiff)) {
        toRemove.push_back(it.index);
        toAdd.push_back(getEffect(prevPos, curTime + 500, Glyph('*', color(255, 100, 0))));
      }
    }
  }
  for (i = toRemove.size() - 1; i >= 0; --i)
    g->objects.remove(toRemove[i]);
  while (!toAdd.empty())
    g->objects.push_back(toAdd.pop_back());
}

export void spawnProjectile(Game mutable *g, GameObject* o, double dir, Glyph glyph) {
  const vdir = vec2d(sin(dir), cos(dir));
  g->objects.push_back(GameObject(
      o->pos + vdir * 1.0,
      move(glyph),
      BoundingBox(0.4),
      null,
      Projectile(vdir * 10.0),
      false,
      null
  ));
}

GameObject getEffect(vec2d pos, int timeout, Glyph glyph) {
  return GameObject(
      pos,
      move(glyph),
      null,
      null,
      null,
      false,
      timeout
  );
}

export GameObject* getPlayer(Game* g) {
  return &g->objects[0];
}

export GameObject mutable* getPlayer(Game mutable* g) {
  return &g->objects[0];
}

GameObject getCreature(vec2d pos, Glyph glyph) {
  return GameObject(pos, move(glyph), BoundingBox(1.0), Creature(), null, false, null);
}

GameObject getFurniture(vec2d pos, Glyph glyph) {
  return GameObject(pos, move(glyph), BoundingBox(1.0),  null, null, true, null);
}

vector<GameObject> getObjects() {
  mutable ret = vector<GameObject>();
  const playerPos = vec2d(150, 150);
  ret.push_back(getCreature(playerPos, Glyph('@', color(255, 255, 255))));
  const roomSize = 3;
  const roomCenter = playerPos - vec2d(roomSize + 3.0, 0.0);
  ret.push_back(getCreature(roomCenter, Glyph('&', color(255, 0, 0))));
  for (i : range(-roomSize, roomSize + 1)) {
    const g = Glyph('#', color(210, 105, 30));
    if (i != 0)
      ret.push_back(getFurniture(vec2d(roomCenter.x + i, roomCenter.y - roomSize), g.copy()));
    ret.push_back(getFurniture(vec2d(roomCenter.x + i, roomCenter.y + roomSize), g.copy()));
    ret.push_back(getFurniture(vec2d(roomCenter.x - roomSize, roomCenter.y + i), g.copy()));
    ret.push_back(getFurniture(vec2d(roomCenter.x + roomSize, roomCenter.y + i), g.copy()));
  }
  return move(ret);
}

export Game() {
  return Game::Game(Level("Level 1", vec2(300, 300)), getObjects());
}

