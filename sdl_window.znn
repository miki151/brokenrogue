
embed {
#include "SDL.h"
}

export import "std/enum_map.znn";

import "std/io.znn";

export import "sdl_surface.znn";
export import "sdl_texture.znn";
import "std/math.znn";

extern struct SDL_Window;
extern struct SDL_Renderer;

export embed {
  struct SDL_Window;
  struct SDL_Renderer;
}

export struct sdl_window {
  SDL_Window mutable* window;
  SDL_Renderer mutable* renderer;
};

export vec2 size(sdl_window* window) {
  mutable ret = vec2(0, 0);
  embed {
    SDL_GetWindowSize(window->window, &ret.x, &ret.y);
  }
  return move(ret);
}

export void!string filled_rectangle(sdl_window* s, rectangle* rect, color color) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    SDL_Rect sdlRect{rect->v1.x, rect->v1.y, rect->v2.x - rect->v1.x, rect->v2.y - rect->v1.y};
    if (SDL_SetRenderDrawColor(s->renderer, color.r, color.g, color.b, 255) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    if (SDL_RenderFillRect(s->renderer, &sdlRect) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}

export void!string outlined_rectangle(sdl_window* s, rectangle* rect, color color, int width) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    SDL_Rect sdlRect{rect->v1.x, rect->v1.y, rect->v2.x - rect->v1.x, rect->v2.y - rect->v1.y};
    if (SDL_SetRenderDrawColor(s->renderer, color.r, color.g, color.b, 255) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    if (SDL_RenderDrawRect(s->renderer, &sdlRect) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}

export void!string blit_from(sdl_window* dst, vec2 coord, sdl_texture* src, vec2? size) {
  const get_error = [](string s) -> expected<void, string> {
    return s;
  };
  const src_size = size ?? *src->size();
  embed {
    SDL_Rect rect{coord.x, coord.y, src_size.x, src_size.y};
    SDL_Rect srcRect{0, 0, src_size.x, src_size.y};
    if (SDL_RenderCopy(dst->renderer, src->texture, &srcRect, &rect) != 0)
      return invoke(&get_error, zenon_string::reference(SDL_GetError()));
  }
}

export void update(sdl_window* window) {
  embed {
    SDL_RenderPresent(window->renderer);
  }
}

export sdl_window!string sdl_create_window(vec2? size, string title) {
  mutable sdl_window? ret = null;
  mutable string? errorRet = null;
  const gen_error = [] (string s) -> expected<sdl_window, string> {
    return "Error creating window: {s}";
  };
  embed {
    SDL_Rect gScreenRect = { 0, 0, 320, 240 };
    SDL_DisplayMode displayMode;
    if( SDL_GetCurrentDisplayMode( 0, &displayMode ) == 0 ) {
      gScreenRect.w = displayMode.w;
      gScreenRect.h = displayMode.h;
    }

    auto window = SDL_CreateWindow(title.data(), SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED, size ? size->x : gScreenRect.w, size ? size->y : gScreenRect.y,
        0 );
    if (!window)
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    auto renderer = SDL_CreateRenderer(window, -1, 0);
    if (!renderer)
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    ret = sdl_window{window, renderer};
    if (-1 != SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt")) {
      auto res = SDL_NumJoysticks();
      if (res < 0)
        return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
      if (res == 0)
        return invoke(&gen_error, zenon_string::reference("No joysticks found"));
      if (!SDL_JoystickOpen(0))
        return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    }
  }
  return *move(ret);
}

void filled_triangle_bottom(sdl_window* dst, vec2 v1, vec2 v2, vec2 v3) {
  const invslope1 = (v2.x - v1.x).as_double() / (v2.y - v1.y);
  const invslope2 = (v3.x - v1.x).as_double() / (v3.y - v1.y);

  mutable curx1 = v1.x.as_double();
  mutable curx2 = v1.x.as_double();
  for (scanlineY = v1.y; scanlineY <= v2.y; ++scanlineY) {
    embed {
      SDL_RenderDrawLine(dst->renderer, (int)curx1, scanlineY, (int)curx2, scanlineY);
    }
    curx1 += invslope1;
    curx2 += invslope2;
  } 
}

export void filled_triangle_top(sdl_window* dst, vec2 v1, vec2 v2, vec2 v3) {
  const invslope1 = (v3.x - v1.x).as_double() / (v3.y - v1.y);
  const invslope2 = (v3.x - v2.x).as_double() / (v3.y - v2.y);

  mutable curx1 = v3.x.as_double();
  mutable curx2 = v3.x.as_double();
  for (scanlineY = v3.y; scanlineY > v1.y; --scanlineY) {
    embed {
      SDL_RenderDrawLine(dst->renderer, (int)curx1, scanlineY, (int)curx2, scanlineY);
    }
    curx1 -= invslope1;
    curx2 -= invslope2;
  } 
}

void sort_points(vec2 mutable* p1, vec2 mutable* p2, vec2 mutable* p3) {
  const swap = [](vec2 mutable* v, vec2 mutable* w) {
    const x = *v;
    *v = *w;
    *w = x;
  };
  if (p2->y < p1->y)
    swap(p1, p2);
  if (p3->y < p2->y) {
    swap(p3, p2);
    if (p2->y < p1->y)
      swap(p2, p1);
  }
}

export void!string filled_triangle(sdl_window* dst, mutable vec2 p1, mutable vec2 p2, mutable vec2 p3, color color) {
  const getError = [](string s) -> expected<void, string> {
    return s;
  };
  embed {
    if (SDL_SetRenderDrawColor(dst->renderer, color.r, color.g, color.b, 255) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
  sort_points(&p1, &p2, &p3);
  if (p2.y == p3.y)
    dst->filled_triangle_bottom(p1, p2, p3);
  else if (p1.y == p2.y)
    dst->filled_triangle_top(p1, p2, p3);
  else {
    const p4 = vec2(p1.x + ((p2.y - p1.y).as_double() / (p3.y - p1.y) * (p3.x - p1.x)).as_int(), p2.y);
    dst->filled_triangle_bottom(p1, p2, p4);
    dst->filled_triangle_top(p2, p4, p3);
  }
}
