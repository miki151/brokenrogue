
embed {
#include "SDL.h"
}

export import "std/enum_map.znn";

import "std/io.znn";

export import "sdl_surface.znn";
export import "sdl_texture.znn";

extern struct SDL_Window;
extern struct SDL_Renderer;

export embed {
  struct SDL_Window;
  struct SDL_Renderer;
}

export struct sdl_window {
  SDL_Window mutable* window;
  SDL_Renderer mutable* renderer;
};

/*export sdl_surface!string get_surface(sdl_window* window) {
  mutable sdl_surface? ret = null;
  mutable string? errorRet = null;
  embed {
    auto surface = SDL_GetWindowSurface(window->window);
    if (!surface)
      errorRet = zenon_string::reference(SDL_GetError());
    else
      ret = sdl_surface{surface};
  }
  if (ret)
    return *move(ret);
  else
    return *errorRet;
}*/

export vec2 size(sdl_window* window) {
  mutable ret = vec2(0, 0);
  embed {
    SDL_GetWindowSize(window->window, &ret.x, &ret.y);
  }
  return move(ret);
}

export void!string filled_rectangle(sdl_window* s, rectangle* rect, color color) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    SDL_Rect sdlRect{rect->v1.x, rect->v1.y, rect->v2.x - rect->v1.x, rect->v2.y - rect->v1.y};
    if (SDL_SetRenderDrawColor(s->renderer, color.r, color.g, color.b, 255) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    if (SDL_RenderFillRect(s->renderer, &sdlRect) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}

export void!string outlined_rectangle(sdl_window* s, rectangle* rect, color color, int width) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    SDL_Rect sdlRect{rect->v1.x, rect->v1.y, rect->v2.x - rect->v1.x, rect->v2.y - rect->v1.y};
    if (SDL_SetRenderDrawColor(s->renderer, color.r, color.g, color.b, 255) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    if (SDL_RenderDrawRect(s->renderer, &sdlRect) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}

export void!string blit_from(sdl_window* dst, vec2 coord, sdl_texture* src, vec2? size) {
  const get_error = [](string s) -> expected<void, string> {
    return s;
  };
  const src_size = size ?? *src->size();
  embed {
    SDL_Rect rect{coord.x, coord.y, src_size.x, src_size.y};
    SDL_Rect srcRect{0, 0, src_size.x, src_size.y};
    if (SDL_RenderCopy(dst->renderer, src->texture, &srcRect, &rect) != 0)
      return invoke(&get_error, zenon_string::reference(SDL_GetError()));
  }
}

export void update(sdl_window* window) {
  embed {
    SDL_RenderPresent(window->renderer);
  }
}

export sdl_window!string sdl_create_window(vec2? size, string title) {
  mutable sdl_window? ret = null;
  mutable string? errorRet = null;
  const gen_error = [] (string s) -> expected<sdl_window, string> {
    return "Error creating window: {s}";
  };
  embed {
    SDL_Rect gScreenRect = { 0, 0, 320, 240 };
    SDL_DisplayMode displayMode;
    if( SDL_GetCurrentDisplayMode( 0, &displayMode ) == 0 ) {
      gScreenRect.w = displayMode.w;
      gScreenRect.h = displayMode.h;
    }

    auto window = SDL_CreateWindow(title.data(), SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED, size ? size->x : gScreenRect.w, size ? size->y : gScreenRect.y,
        0 );
    if (!window)
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    auto renderer = SDL_CreateRenderer(window, -1, 0);
    if (!renderer)
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    ret = sdl_window{window, renderer};
/*    if (-1 == SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt"))
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    auto res = SDL_NumJoysticks();
    if (res < 0)
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));
    if (res == 0)
      return invoke(&gen_error, zenon_string::reference("No joysticks found"));
    if (!SDL_JoystickOpen(0))
      return invoke(&gen_error, zenon_string::reference(SDL_GetError()));*/
  }
  return *move(ret);
}

