
export import "std/expected.znn";
export import "color.znn";
export import "vec2.znn";
import "sdl_surface.znn";
import "sdl_window.znn";

embed {
//#include "SDL.h"
//#include "SDL_ttf.h"
}

extern struct FC_Font;

embed {
#include "SDL_FontCache.h"
}

export embed {
  struct FC_Font;
}

export struct sdl_font {
  FC_Font mutable* font;
};

export sdl_font!string load_sdl_font(sdl_window* window, string path, int size) {
  const gen_error = [] (string s) -> expected<sdl_font, string> {
    return s;
  };
  const gen_value = [] (FC_Font mutable* f) -> expected<sdl_font, string> {
    return sdl_font(f);
  };
  embed_returns {
    auto font = FC_CreateFont();
    if (!FC_LoadFont(font, window->renderer, path.data(), size, FC_MakeColor(255, 255, 255, 255),
        TTF_STYLE_NORMAL))
      return invoke(&gen_error, zenon_string::reference(TTF_GetError()));
    return invoke(&gen_value, font);
  }
}

export void!string draw_text(sdl_window* window, vec2 pos, sdl_font* font, color color, string text) {
  embed {
    FC_DrawColor(font->font, window->renderer, pos.x, pos.y, FC_MakeColor(color.r, color.g, color.b, 255), "%s", text.data());
  }
}

export vec2 get_text_size(sdl_font* font, string text) {
  embed_returns {
    return {FC_GetWidth(font->font, "%s", text.data()), FC_GetHeight(font->font, "%s", text.data())};
  }
}

embed {
#include "SDL_FontCache.c"
}
