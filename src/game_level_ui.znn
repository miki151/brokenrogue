
export import "ui_canvas.znn";
import "rectangle.znn";
import "ui_event.znn";
import "game.znn";
export import "std/any.znn";
import "std/io.znn";
export import "ui.znn";
import "rectangle.znn";
import "ui_state.znn";
import "std/time.znn";
export import "glyph.znn";

export [@ui_element]
struct GameLevelUI {
  bool seeWholeMap;
  int tileSize;
  double fontRatio;
  int jumpDuration;
  int woundedAnimDuration;
  int explosionDuration;
  double jumpHeight;
  double viewAngle;
  double cameraSensitivity;
  double joystickMovementDeadRange;
  double minJoystickMovement;
  key_event forwardKey;
  key_event backwardKey;
  key_event leftKey;
  key_event rightKey;
  key_event waitKey;
  key_event meleeKey;
  key_event shootKey;
  key_event changeLevelKey;
  box<UIElement> stairsMessage;
};

int getFontSize(GameLevelUI* ui) {
  return (ui->fontRatio * ui->tileSize).as_int();
}

export struct HighlightedObjectInfo {
  Glyph glyph;
  string name;
  double hp;
};

export HighlightedObjectInfo copy(HighlightedObjectInfo*) = default;

export struct GameLevelUIData {
  Game mutable* game;
  invoke<void, int>* timeSpentCallback;
  invoke<void, HighlightedObjectInfo?>* highlightedObjectCallback;
};

export bool onKeyEvent(GameLevelUI* ui, UIContext context, rectangle*, key_event* event) {
  const state = context.state->get_state<GameLevelUIState>();
  const data = *context.data->cast_to<GameLevelUIData>();
  const player = data->game->getPlayer();
  if (*event == ui->forwardKey)
    discard player->walk(data->game, context.timeDiff, state->playerDir, null);
  else if (*event == ui->backwardKey)
    discard player->walk(data->game, -context.timeDiff, state->playerDir, null);
  else if (*event == ui->leftKey)
    discard player->walk(data->game, context.timeDiff, state->playerDir + 1.57, null);
  else if (*event == ui->rightKey)
    discard player->walk(data->game, context.timeDiff, state->playerDir - 1.57, null);
  else if (*event == ui->shootKey)
    shoot(context);
  else if (*event == ui->meleeKey) {
    discard player->addMeleeAttack(state->playerDir);
  }
  else if (*event == ui->changeLevelKey && data->game->canUseStairs()) {
    data->game->useStairs();
    return true;
  } else if (*event != ui->waitKey)
    return false;
  data->game->advance(context.timeDiff);
  return true;
}

vec2 projectOnScreen(GameLevelUI* ui, GameObject* player, vec2d pos, double playerDir) {
  const diff = pos - player->pos;
  const dist = ui->tileSize.as_double() * diff.length_d();
  const angle = playerDir - atan2(diff.x, diff.y);
  return vec2((sin(angle) * dist).as_int(), (-cos(angle) * dist * ui->viewAngle).as_int());
}

export struct GameLevelUIState {
  double playerDir;
};

export GameLevelUIState() {
  return GameLevelUIState::GameLevelUIState(0.0);
}

void shoot(UIContext context) {
  const state = context.state->get_state<GameLevelUIState>();
  const data = *context.data->cast_to<GameLevelUIData>();
  discard data->game->addRangedAttack(data->game->getPlayer(), state->playerDir);
  data->timeSpentCallback->invoke(30);
}

export bool onMouseEvent(GameLevelUI* ui, UIContext context, rectangle*, mouse_event* event) {
  const state = context.state->get_state<GameLevelUIState>();
  const data = *context.data->cast_to<GameLevelUIData>();
  const player = data->game->getPlayer();
  switch (event->type) {
    case (JOYSTICK_RIGHT) {
      state->playerDir -= context.timeDiff * ui->cameraSensitivity * event->pos.x;
    }
    case (JOYSTICK_LEFT) {
      mutable pos = event->pos;
      if (abs(pos.x).as_double() < abs(pos.y) * ui->joystickMovementDeadRange)
        pos.x = 0;
      if (abs(pos.y).as_double() < abs(pos.x) * ui->joystickMovementDeadRange)
        pos.y = 0;
      const angle = state->playerDir + atan2(pos.x, pos.y);
      const length = pos.length_d();
      if (length > 1000 * ui->minJoystickMovement) {
        discard player->walk(data->game, -context.timeDiff * length / 1000, angle, null);
        data->game->advance(fabs(context.timeDiff * length / 1000));
      }
    }
    case (RIGHT) {
      shoot(context);
    }
    case (LEFT) {
      discard player->addMeleeAttack(state->playerDir);
    }
    default {
      return false;
    }
  }
  return true;
}

double getJumpOffset(mutable double state) {
  if (state > 0.5)
    state -= 0.5;
  state *= 2;
  return 1.0 - (2.0 * state - 1) * (2.0 * state - 1);
}

struct GlyphRenderElem {
  Glyph glyph;
  vec2 pos;
};

void drawBloodParticle(GameLevelUI* ui, UIContext context, vec2 origin, int start, int curTime) {
  const h = ui->getFontSize() * 2 / 3;
  const w = (((abs(start) % 100 * 67) % 100) / 50.0 - 1) * ui->getFontSize() / 3;
  const t = curTime - start;
  const dur = ui->woundedAnimDuration;
  const offset = vec2((w * t / dur).as_int(), (h * t * t / (dur * dur) - h / 2).as_int());
  const pos = origin + offset;
  Glyph("*", color(255, 0, 0), 0.5).render(context.canvas, ui->getFontSize(), pos);
}

export void render(GameLevelUI* ui, UIContext context, rectangle* r) {
  const data = *context.data->cast_to<GameLevelUIData>();
  const player = data->game->getPlayer();
  const origin = vec2(r->middle().x, (r->top() + 2 * r->bottom()) / 3);
  const to_draw = r->plus_margin(ui->tileSize);
  const state = context.state->get_state<GameLevelUIState>();
  for (pos : centered_rect(player->pos.as_int(), data->game->lineOfSight))
    if (const t = data->game->getLevel()->getTile(*pos)) {
      const coord = origin + ui->projectOnScreen(player, pos->as_double(), state->playerDir);
      if (to_draw.contains(&coord) && (ui->seeWholeMap || data->game->canSee(player, *pos)))
        (*t)->glyph.render(context.canvas, ui->getFontSize(), coord);
    }
  mutable toRender = vector<GlyphRenderElem>();
  const curTime = current_time_milli();
  mutable highlightedObject = player;
  mutable bestAngle = 100000.0;
  for (it : *data->game->getObjects()) {
    const obj = it->get();
    const canSee = ui->seeWholeMap || data->game->canSee(player, obj->pos.as_int());
    if ((!obj->ongoingAttack || !!obj->ongoingAttack->attack.glyph) && (canSee || obj->remember)) {
      const projected = ui->projectOnScreen(player, obj->pos, state->playerDir);
      if (obj != player && !!obj->attributes.creature) {
        const angle = fabs(atan2(projected.x, -projected.y));
        if (angle < bestAngle) {
          bestAngle = angle;
          highlightedObject = obj;
        }
      }
      const coord = origin + projected;
      if (to_draw.contains(&coord)) {
        const jumpState = ((curTime % ui->jumpDuration + ui->jumpDuration) % ui->jumpDuration).as_double() 
            / ui->jumpDuration;
        const offset = !obj->animation.lastMovement
            || *obj->animation.lastMovement < curTime - (1000 * context.timeDiff).as_int() - 10
            ? 0
            : (ui->getFontSize() * ui->jumpHeight * getJumpOffset(jumpState)).as_int();
        toRender.push_back(GlyphRenderElem(obj->attributes.glyph.copy(), coord - vec2(0, offset)));
        if (!canSee && obj->remember)
          toRender.back()->glyph.col = color(100, 100, 100);
        else if (obj->attributes.canRemember)
          obj->remember = true;
      }
    }
  }
  if (highlightedObject != player)
    data->highlightedObjectCallback->invoke(HighlightedObjectInfo(
        highlightedObject->attributes.glyph.copy(),
        highlightedObject->attributes.name,
        *highlightedObject->health / *highlightedObject->attributes.maxHealth));
  else {
    const HighlightedObjectInfo? tmp = null;
    data->highlightedObjectCallback->invoke(move(tmp));
  }
  toRender.sort(&[](GlyphRenderElem* p1, GlyphRenderElem* p2) {
      return p1->pos.y < p2->pos.y;
  });
  for (elem : toRender)
    elem->glyph.render(context.canvas, ui->getFontSize(), elem->pos);
  for (it : *data->game->getObjects()) {
    const obj = it->get();
    mutable double? forceDir = null;
    if (&*obj == data->game->getPlayer() && !obj->ongoingAttack)
      forceDir = state->playerDir;
    if (const weapon = obj->getMeleeWeaponPosition(forceDir))
      if (ui->seeWholeMap || data->game->canSee(player, obj->pos.as_int())) {
        const coord = origin + ui->projectOnScreen(player, weapon->pos, state->playerDir);
        if (to_draw.contains(&coord))
          (obj->attributes.creature->meleeAttack->glyph ?? obj->attributes.glyph).render(
              context.canvas, ui->getFontSize(), coord,
              !!obj->attributes.creature->meleeAttack->glyph ? state->playerDir - weapon->dir : 0);
      }
  }
  for (anim : data->game->getLevel()->animations) {
    const coord = origin + ui->projectOnScreen(player, anim->position, state->playerDir);
    if (to_draw.contains(&coord))
      switch (anim->type) {
        case (EXPLOSION) {
          if (anim->time + ui->explosionDuration > curTime)
            Glyph("*", color(255, 100, 0), 1.0).render(context.canvas, ui->getFontSize(), coord);
        }
        case (BLOOD) {
          if (anim->time + ui->woundedAnimDuration > curTime)
            drawBloodParticle(ui, context, coord, anim->time, curTime);
        }
      }
  }
  if (const message = data->game->getMessage(player->pos)) {
    const messagePos = origin + vec2(0, 60);
    const ctx = UIContext(context.canvas, &*message, context.state, context.timeDiff);
    const size = ui->stairsMessage->size(ctx);
    ui->stairsMessage->render(ctx, &rectangle(messagePos - size / 2, messagePos + size / 2));
  }
}


