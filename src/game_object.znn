
export import "game_object_attributes.znn";
export import "game_object_animation.znn";
export import "vec2.znn";
export import "std/range.znn";
export import "melee_attack.znn";
import "std/math.znn";
export import "table.znn";
export import "projectile.znn";
export import "std/hash_set.znn";

export struct MeleeWeaponPosition {
  vec2d pos1;
  vec2d pos2;
  double dir;
};

export MeleeWeaponPosition? getMeleeWeaponPosition(GameObject* object, double? forceDir) {
  if (!object->attributes.creature || !object->attributes.creature->meleeAttack)
    return null;
  const attack = &*object->attributes.creature->meleeAttack;
  const state = !object->ongoingAttack ? 0
      : object->ongoingAttack->remainingTime / object->ongoingAttack->attack.duration;
  const offset = object->attributes.box->size / 2.2;
  const reach = attack->reach;
  const length = attack->length;
  mutable dir = (forceDir ?? (!object->ongoingAttack ? object->lastWalkDirection : object->ongoingAttack->dir));
  mutable offsetV = vec2d(0, 0);
  switch (attack->origin) {
    case (LEFT) {
      offsetV = vec2d(sin(dir + 1.57), cos(dir + 1.57)) * offset;
      dir -= atan2(offset, reach) / 2; 
    }
    case (RIGHT) {
      offsetV = vec2d(sin(dir - 1.57), cos(dir - 1.57)) * offset;
      dir += atan2(offset, reach) / 2;
    }
    case (CENTER) {
      offsetV = vec2d(sin(dir), cos(dir)) * (offset / 2.0);
    }
  }
  return MeleeWeaponPosition(
      object->pos + offsetV + vec2d(sin(dir), cos(dir)) * reach * (1 - 2 * fabs(state - 0.5)),
      object->pos + offsetV + vec2d(sin(dir), cos(dir)) * (reach * (1 - 2 * fabs(state - 0.5) + length)),
      dir
  );
}

export vec2d getMaxMeleeAttackPosition(GameObject* object, double dir) {
  return object->pos + vec2d(sin(dir), cos(dir)) * (
      object->attributes.creature->meleeAttack->reach +
      object->attributes.creature->meleeAttack->glyph.size);
}

export bool isPenetrated(GameObject* object, vec2d pos) {
  return !!object->attributes.box && object->attributes.box->isPenetrated(pos - object->pos);
}

export struct MeleeAttackInfo {
  MeleeAttack attack;
  double remainingTime;
  double dir;
  hash_set<int> woundedObjects;
};

export struct FOVInfo {
  vec2 origin;
  table<int> data;
};

export struct GameObject {
  int id;
  vec2d pos;
  GameObjectAnimation animation;
  GameObjectAttributes attributes;
  string? attributesId;
  MeleeAttackInfo? ongoingAttack;
  double rangedAttackTimeout;
  int rangedAttackProjectileCount;
  FOVInfo? fovInfo;
  Projectile? projectile;
  double? health;
  bool remember;
  double lastWalkDirection;
};

export GameObject(int id, vec2d pos, GameObjectAttributes attr, string? attributesId) {
  const health = attr.maxHealth.map_to(&[](int* a) { return a->as_double(); });
  return GameObject::GameObject(id, pos, GameObjectAnimation(), move(attr), attributesId, null, 0, 0, null, null,
      health, false, 0);
}

export bool addMeleeAttack(GameObject mutable* o, double direction) {
  if (!o->ongoingAttack && !!o->attributes.creature && !!o->attributes.creature->meleeAttack) {
    const duration = o->attributes.creature->meleeAttack->duration;
    o->ongoingAttack = MeleeAttackInfo(o->attributes.creature->meleeAttack->copy(), duration, direction,
        hash_set<int>());
    return true;
  }
  return false;
}

export vec2d? getRebound(GameObject* o1, GameObject* o2) {
  if (!!o1->attributes.box && !!o2->attributes.box)
    return getRebound(&*o1->attributes.box, &*o2->attributes.box, o1->pos - o2->pos);
  return null;
}

