
export import "game_object_attributes.znn";
export import "game_object_animation.znn";
export import "vec2.znn";
export import "std/range.znn";
export import "melee_attack.znn";
import "std/math.znn";
export import "table.znn";
export import "projectile.znn";

export vec2d getPosition(MeleeAttackInfo* info) {
  const state = info->remainingTime / info->attack.duration;
  return vec2d(sin(info->dir), cos(info->dir)) * (info->attack.reach * (1 - 2 * fabs(state - 0.5)));
}

export vec2d getMaxMeleeAttackPosition(GameObject* object, double dir) {
  return vec2d(sin(dir), cos(dir)) * object->attributes.creature->meleeAttack->reach;
}

export struct MeleeAttackInfo {
  MeleeAttack attack;
  double remainingTime;
  double dir;
  bool nullified;
};

export struct FOVInfo {
  vec2 origin;
  table<int> data;
};

export struct GameObject {
  vec2d pos;
  GameObjectAnimation animation;
  GameObjectAttributes attributes;
  MeleeAttackInfo? ongoingAttack;
  double rangedAttackTimeout;
  int rangedAttackProjectileCount;
  FOVInfo? fovInfo;
  Projectile? projectile;
  double? health;
  bool remember;
};

export GameObject(vec2d pos, GameObjectAttributes attr) {
  const health = attr.maxHealth.map_to(&[](int* a) { return a->as_double(); });
  return GameObject::GameObject(pos, GameObjectAnimation(), move(attr), null, 0, 0, null, null, health,
      false);
}

export bool addMeleeAttack(GameObject mutable* o, double direction) {
  if (!o->ongoingAttack && !!o->attributes.creature && !!o->attributes.creature->meleeAttack) {
    const duration = o->attributes.creature->meleeAttack->duration;
    o->ongoingAttack = MeleeAttackInfo(o->attributes.creature->meleeAttack->copy(), duration, direction, false);
    return true;
  }
  return false;
}

export vec2d? getRebound(GameObject* o1, GameObject* o2) {
  if (!!o1->attributes.box && !!o2->attributes.box)
    return getRebound(&*o1->attributes.box, &*o2->attributes.box, o1->pos - o2->pos);
  return null;
}

