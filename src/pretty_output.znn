export import "std/io.znn";
export import "std/panic.znn";
export import "std/enum.znn";
export import "std/vector.znn";
export import "std/union.znn";

export template <Output> requires invoke<Output, void, string>
void printIndent(Output* output, int count) {
  for (i = 0; i < count; ++i)
    output->invoke(" ");
}

export template <T>
struct dummy {};

export template <T, string message> requires (T == dummy<T>)
void compile_error() {
}

export template <Output>
struct PrettyOutput {
  Output output;
  int currentIndent;
  int indent;
};

export template <Output> requires invoke<Output, void, string>
PrettyOutput(int indent, Output output) {
  return PrettyOutput<Output>::PrettyOutput(move(output), 0, indent);
}

export template <Output>
void destruct(PrettyOutput<Output>* ar) {
  assert(ar->currentIndent == 0, "Text indent non-zero upon closing: {ar->currentIndent}");
}

export template <Output, T>
void print(PrettyOutput<Output> mutable*, T*) {
  compile_error<T, "Don't know how to print this type">();
}

export template <Output> requires invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, string* s) {
  ar->output("\"{*s}\"");
}

export template <Output> requires invoke<Output, void, string>
void newLine(PrettyOutput<Output> mutable* ar) {
  ar->output("\n");
  printIndent(&ar->output, ar->currentIndent * ar->indent);
}

export template <Output> requires invoke<Output, void, string>
void output(PrettyOutput<Output> mutable* ar, string s) {
  ar->output.invoke(s);
}

export template <Output> requires invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, bool* b) {
  if (*b)
    ar->output("true");
  else
    ar->output("false");
}

export template <Output, T> requires invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, T?* elem) {
  if (*elem)
    ar->print(&**elem);
  else
    ar->output("null");
}

export template <Output, T> requires invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, vector<T>* elem) {
  ar->output("\{");
  ar->currentIndent += 1;
  for (it : *elem) {
    ar->newLine();
    ar->print(&*it);
  }
  ar->currentIndent -= 1;
  ar->newLine();
  ar->output("\}");
}

export template <Output> requires invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, int* a) {
  ar->output("{*a}");
}

export template <Output, T> requires is_enum<T>, invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, T* a) {
  ar->output("{a->asString()}");
}

export template <Output, T> requires is_struct<T>, invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, T* t) {
  ar->output("\{");
  ar->currentIndent += 1;
  static for (i = 0; i < struct_count(T); ++i) {
    ar->newLine();
    ar->output("{get_member_name(T, i)} = ");
    unchecked ar->print(t->get_member<i>());
  }
  ar->currentIndent -= 1;
  ar->newLine();
  ar->output("\}");
}

export template <Output, T> requires is_union<T>, invoke<Output, void, string>
void print(PrettyOutput<Output> mutable* ar, T* t) {
  static for (i = 0; i < union_count(T); ++i)
    if (i == t->get_index()) {
      ar->output("{get_alternative_name(T, i)} ");
//      ar->print(t->get_alternative<i>);
    }
}


