
import "game.znn";
import "std/math.znn";
import "std/io.znn";
export import "std/vector.znn";
export import "std/box.znn";


bool canReachMelee(GameObject* obj, GameObject* target) {
  const dir = (target->pos - obj->pos).angle();
  // Test some intermediate points in case we can reach beyond the target.
  for (i = 0.0; i <= 1.0; i += 0.1)
    if (target->isPenetrated(obj->getMaxMeleeAttackPosition(dir) * i + obj->pos * (1.0 - i)))
      return true;
  return false;
}

export struct AIAvoidMelee {};

export AIAvoidMelee copy(AIAvoidMelee*) = default;

export bool makeMove(AIAvoidMelee*, Game mutable* game, GameObject mutable* object, double timeDiff) {
  const obj = game->getPlayer();
  if (canReachMelee(obj, object) && !!obj->ongoingAttack) {
    const dir = (object->pos - obj->pos).angle();
    discard object->walk(game, timeDiff, dir, -dir);
    return true;
  }
  return false;
}

export struct AIMelee {};

export AIMelee copy(AIMelee*) = default;

export bool makeMove(AIMelee*, Game mutable* game, GameObject mutable* object, double) {
  if (!object->attributes.creature->meleeAttack)
    return false;
  const obj = game->getPlayer();
  return canReachMelee(object, obj) && object->addMeleeAttack((obj->pos - object->pos).angle());
}

export struct AIRanged {};

export AIRanged copy(AIRanged*) = default;

export bool makeMove(AIRanged*, Game mutable* game, GameObject mutable* object, double) {
  if (!object->attributes.creature->rangedAttack)
    return false;
  const obj = game->getPlayer();
  return game->canSee(object, obj->pos.as_int()) && game->addRangedAttack(object, (obj->pos - object->pos).angle());
}

export struct AIPathfind {};
export AIPathfind copy(AIPathfind*) = default;

export bool makeMove(AIPathfind*, Game mutable* game, GameObject mutable* object, double timeDiff) {
  const obj = game->getPlayer();
  return game->canSee(object, obj->pos.as_int())
      && !canReachMelee(object, obj)
      && !!object->walk(game, timeDiff, (obj->pos - object->pos).angle(), null);
}

export struct AICircle {};
export AICircle copy(AICircle*) = default;

export bool makeMove(AICircle*, Game mutable* game, GameObject mutable* object, double timeDiff) {
  const obj = game->getPlayer();
  return game->canSee(object, obj->pos.as_int())
      && !canReachMelee(object, obj)
      && !!object->walk(game, timeDiff, (obj->pos - object->pos).angle() + 1.57, null)
      && false;
}

export struct AIAll {
  vector<AI> elems;
};
export AIAll copy(AIAll*) = default;

export bool makeMove(AIAll* first, Game mutable* game, GameObject mutable* object, double timeDiff) {
  mutable res = false;
  for (elem : first->elems)
    res = elem->makeMove(game, object, timeDiff) || res;
  return res;
}

export union AI {
  AIMelee melee;
  AIRanged ranged;
  AIAvoidMelee avoidMelee;
  AIPathfind pathfind;
  AICircle circle;
  AIAll all;
};

export AI copy(AI*) = default;

export bool makeMove(virtual AI*, Game mutable* game, GameObject mutable* object, double timeDiff);

