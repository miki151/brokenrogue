
export import "std/expected.znn";
export import "std/vector.znn";
export import "vec2.znn";
export import "rectangle.znn";
export import "color.znn";
export import "ui_canvas.znn";
export import "ui_event.znn";
import "ui_data.znn";
export import "std/math.znn";
export import "std/any.znn";
export import "std/io.znn";
export import "std/box.znn";
export import "ui_state.znn";
import "rectangle_placement.znn";

export struct UIContext {
  UICanvas* canvas;
  any* data;
  UIState mutable* state;
  double timeDiff;
};

export UIContext implicit_copy(UIContext*) = default;

export concept<T> UIElement {
  void render(T*, UIContext, rectangle*);
  vec2 size(T*, UIContext);
  bool onKeyEvent(T*, UIContext, rectangle*, key_event*);
  bool onMouseEvent(T*, UIContext, rectangle*, mouse_event*);
  void destruct(T*);
};

export concept<T> container_ui {
  box<UIElement>[] get_elems(T*);
  rectangle get_bounds(T*, int index, UIContext, rectangle* bounds);
  any*!string transform_data(T*, any*);
};

export attribute @ui_element;

export template <T> requires has_attribute<T, @ui_element>
void render(T*, UIContext, rectangle*) {}

export template <T> requires has_attribute<T, @ui_element>
vec2 size(T*, UIContext) {
  return vec2(0, 0);
}

export template <T> requires has_attribute<T, @ui_element>
bool onKeyEvent(T*, UIContext, rectangle*, key_event*) {
  return false;
}

export template <T> requires has_attribute<T, @ui_element>
bool onMouseEvent(T*, UIContext, rectangle*, mouse_event*) {
  return false;
}

export template <T>
any*!string transform_data(T*, any* a) {
  return a;
}

export template <T> requires container_ui<T>
void render(T* t, mutable UIContext context, rectangle* r) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    for (elem : t->get_elems())
      elem->get()->render(context, &t->get_bounds(elem.index, context, r));
  } else
    context.canvas->drawText(r->v1, data.get_error(), 10, &color(255, 0, 0));
}

export template <T> requires container_ui<T>
vec2 size(T* t, UIContext context) {
  mutable ret = vec2(0, 0);
  for (elem : t->get_elems()) {
    const sz = elem->get()->size(context);
    ret.x = max(ret.x, sz.x);
    ret.y = max(ret.y, sz.y);
  }
  return ret;
}

export template <T> requires container_ui<T>
bool onKeyEvent(T* t, mutable UIContext context, rectangle* r, key_event* key) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    const elems = t->get_elems();
    for (index = elems.size() - 1; index >= 0; --index)
      if (elems[index]->onKeyEvent(context, r, key))
        return true;
  }
  return false;
}

export template <T> requires container_ui<T>
bool onMouseEvent(T* t, mutable UIContext context, rectangle* r, mouse_event* m) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    const elems = t->get_elems();
    for (index = elems.size() - 1; index >= 0; --index)
      if (elems[index]->onMouseEvent(context, &t->get_bounds(index, context, r), m))
        return true;
  }
  return false;
}

export [@ui_element]
struct texture {
  string id;
  texture_flip flip;
};

export void render(texture* t, UIContext context, rectangle* r) {
  context.canvas->drawTexture(r, t->id, texture_flip::NONE);
}

export vec2 size(texture* t, UIContext context) {
  return context.canvas->getTextureSize(t->id);
}

export [@ui_element]
struct button {
};

export bool onMouseEvent(button* b, UIContext context, rectangle* r, mouse_event* event) {
  if (event->type == mouse_event_type::LEFT && r->contains(&event->pos))
    if (const callback = context.data->cast_to<box<UICallback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

export [@ui_element]
struct label {
  string text;
  int size;
  color color;
};

export void render(label* t, UIContext context, rectangle* r) {
  context.canvas->drawText(r->v1, t->text, t->size, &t->color);
}

export vec2 size(label* t, UIContext context) {
  return context.canvas->getTextSize(t->text, t->size);
}

export [@ui_element]
struct text_ui {
  int size;
  color color;
};

export void render(text_ui* t, UIContext context, rectangle* r) {
  if (const s = context.data->cast_to<string>())
    context.canvas->drawText(r->v1, **s, t->size, &t->color);
}

export vec2 size(text_ui* t, UIContext context) {
  return context.canvas->getTextSize("something", t->size);
}

export [@ui_element]
struct fill {
  color color;
};

export void render(fill* t, UIContext context, rectangle* r) {
  context.canvas->fillRectangle(r, &t->color);
}

export [@ui_element]
struct frame {
  int width;
  color color;
};

export void render(frame* t, UIContext context, rectangle* r) {
  context.canvas->frameRectangle(r, &t->color, t->width);
}

export struct chain {
  vector<box<UIElement>> elems;
};

export box<UIElement>[] get_elems(chain* c) {
  return c->elems.slice();
}

export rectangle get_bounds(chain* c, int, UIContext, rectangle* r) {
  return r->copy();
}

export struct margins {
  int width;
  box<UIElement> elem;
};

export box<UIElement>[] get_elems(margins* m) {
  return singleton_slice(&m->elem);
}

export rectangle get_bounds(margins* c, int, UIContext, rectangle* r) {
  return r->plus_margin(-c->width);
}

export vec2 size(margins* t, UIContext context) {
  return t->elem->size(context) + vec2(t->width, t->width) * 2;
}

export struct position {
  RectanglePlacement placement;
  box<UIElement> elem;
};

export box<UIElement>[] get_elems(position* p) {
  return singleton_slice(&p->elem);
}

export rectangle get_bounds(position* p, int ind, UIContext context, rectangle* r) {
  return p->placement.get(p->elem->size(context), r);
}

export enum list_ui_type {
  HORIZONTAL,
  VERTICAL,
};

export [@ui_element]
struct list_ui {
  list_ui_type type;
  vector<box<UIElement>> elems;
};

vector<rectangle> getElemPositions(list_ui* t, UIContext context, rectangle* r) {
  mutable ret = vector<rectangle>();
  mutable start = 0;
  for (it : t->elems)
    switch (t->type) {
      case (VERTICAL) {
        const height = it->get()->size(context).y;
        ret.push_back(rectangle(vec2(r->left(), r->top() + start),
            vec2(r->right(), r->top() + start + height)));
        start += height;
      }
      case (HORIZONTAL) {
        const width = it->get()->size(context).x;
        ret.push_back(rectangle(vec2(r->left() + start, r->top()),
            vec2(r->left() + start + width, r->bottom())));
        start += width;
      }
    }
  return move(ret);
}

export bool onMouseEvent(list_ui* c, UIContext context, rectangle* rect,
    mouse_event* event) {
  const positions = getElemPositions(c, context, rect);
  for (it : c->elems)
    if (it->get()->onMouseEvent(context, &positions[it.index], event))
      return true;
  return false;
}

export void render(list_ui* t, UIContext context, rectangle* r) {
  const positions = getElemPositions(t, context, r);
  for (it : t->elems)
    it->get()->render(context, &positions[it.index]);
}

export vec2 size(list_ui* t, UIContext context) {
  mutable ret = vec2(0, 0);
  for (it : t->elems) {
    const sz = it->get()->size(context);
    switch (t->type) {
      case (VERTICAL) {
        ret.y += sz.y;
        ret.x = max(ret.x, sz.x);
      }
      case (HORIZONTAL) {
        ret.x += sz.x;
        ret.y = max(ret.y, sz.y);
      }
    }
  }
  return ret;
}

export struct using_ui {
  string key;
  box<UIElement> elem;
};

export box<UIElement>[] get_elems(using_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(using_ui* c, int, UIContext, rectangle* r) {
  return r->copy();
}

export any*!string transform_data(using_ui* u, any* a) {
  if (const r = a->cast_to<UIRecord>()) {
    if (const res = (*r)->data.get_maybe(&u->key))
      return (*res)->get();
    return "";
  } else
    return "Bad UI data: not a record: {a->get_type()}";
}

export struct width_ui {
  int width;
  box<UIElement> elem;
};

export box<UIElement>[] get_elems(width_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(width_ui* c, int, UIContext, rectangle* r) {
  return r->copy();
}

export vec2 size(width_ui* t, UIContext context) {
  return vec2(t->width, t->elem->size(context).y);
}

export struct height_ui {
  int height;
  box<UIElement> elem;
};

export box<UIElement>[] get_elems(height_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(height_ui* c, int, UIContext, rectangle* r) {
  return r->copy();
}

export vec2 size(height_ui* t, UIContext context) {
  return vec2(t->elem->size(context).x, t->height);
}

export [@ui_element]
struct key_handler {
  key_event? event;
};

export bool onKeyEvent(key_handler* k, UIContext context, rectangle* rect, key_event* event) {
  if (!k->event || *event == *k->event)
    if (const callback = context.data->cast_to<box<UICallback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

export [@ui_element]
struct consume_events {
};

export bool onKeyEvent(consume_events*, UIContext, rectangle*, key_event*) {
  return true;
}

export bool onMouseEvent(consume_events*, UIContext, rectangle*, mouse_event*) {
  return true;
}

export [@ui_element]
struct horizontal_bar_ui {
  color color;
};

export void render(horizontal_bar_ui* t, UIContext context, rectangle* r) {
  if (const value = context.data->cast_to<double>()) {
    const rect = rectangle(r->v1, vec2(r->v1.x + (r->width() * **value).as_int(), r->v2.y));
    context.canvas->fillRectangle(&rect, &t->color);
  } else {
    context.canvas->drawText(r->v1,
        "Horibar expected a double value, got {context.data->get_type()}", 20, &color(255, 0, 0));
  }
}

