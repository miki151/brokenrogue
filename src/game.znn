
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "projectile.znn";
export import "table.znn";
export import "glyph.znn";
import "std/time.znn";
import "std/io.znn";
export import "level_generator.znn";
export import "std/hash_map.znn";
export import "level_animation.znn";
export import "game_object.znn";
import "ai.znn";
import "field_of_view.znn";

export struct Tile {
  Glyph glyph;
};

export Tile copy(Tile*) = default;

export struct Level {
  string name;
  table<Tile> tiles;
  vector<box<GameObject>> objects;
  vector<LevelAnimation> animations;
};

export Level(string name, vec2 size, vector<box<GameObject>> objects, vector<LevelAnimation> animations) {
  const tiles = table(size, Tile(Glyph(".", color(80, 80, 80))));
  return Level::Level(name, move(tiles), move(objects), move(animations));
}

export Tile*? getTile(Level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}

export enum GameStatus {
  GAME_LOST,
  GAME_WON
};

export struct Game {
  vector<Level> levels;
  int currentLevel;
  const hash_map<string, GameObjectAttributes>* objectFactory;
  const int lineOfSight;
  GameStatus? status;
  int gameObjectIdCounter;
};

export Level* getLevel(Game* g) {
  return &g->levels[g->currentLevel];
}

export Level mutable* getLevel(Game mutable* g) {
  return &g->levels[g->currentLevel];
}

export void useStairs(Game mutable* g) {
  ++g->currentLevel;
}

export bool canUseStairs(Game* g) {
  if (g->currentLevel == g->levels.size() - 1)
    return false;
  for (it : *g->getObjects())
    if (it->get()->attributes.isStairs && (it->get()->pos - g->getPlayer()->pos).length_d() < 1.0)
      return true;
  return false;
}

export vector<box<GameObject>>* getObjects(Game* g) {
  return &g->getLevel()->objects;
}

export vector<box<GameObject>> mutable* getObjects(Game mutable* g) {
  return &g->getLevel()->objects;
}

export bool canSee(Game* game, GameObject mutable* obj, vec2 position) {
  const posInt = (obj->pos + vec2d(0.5, 0.5)).as_int();
  if (!obj->fovInfo || obj->fovInfo->origin != posInt) {
    obj->fovInfo = FOVInfo(
        posInt,
        table<int>(vec2(game->lineOfSight, game->lineOfSight), 0)
    );
    const getObjPos = [&](GameObject* obj2) { return obj->fovInfo->data.size() / 2 + obj2->pos.as_int() - posInt; };
    for (obj2 : *game->getObjects())
      if (obj2->get()->attributes.blocksVision) {
        const opos = getObjPos(obj2->get());
        if (obj->fovInfo->data.bounds().contains(&opos))
          obj->fovInfo->data[opos] = 1;
      }
    obj->fovInfo->data = calculateFOV(&obj->fovInfo->data);
  }
  const vpos = position - posInt + obj->fovInfo->data.size() / 2;
  return obj->fovInfo->data.bounds().contains(&vpos) && obj->fovInfo->data[vpos] == 1;
}

vector<box<GameObject>> generateObjects(int levelNum, int initialId, vec2 levelSize, LevelGenerator* generator,
    hash_map<string, GameObjectAttributes>* mapping) {
  mutable ret = vector<box<GameObject>>();
  const levelTable = [&] {
    for (i = 0; i < 10; ++i)
      if (const res = generator->generate(levelSize))
        return *move(res);
    panic("Failed to generate level {levelNum}");
  }();
  mutable playerIndex = -1;
  for (v : levelTable.bounds())
    for (token : levelTable[*v])
      if (const attr = mapping->get_maybe(&*token)) {
        if (*token == "player") {
          assert(playerIndex == -1, "Player creature generated more than once");
          playerIndex = ret.size();
        }
        ret.push_back(GameObject(initialId + ret.size(), v->as_double(), (*attr)->copy()).box());
      }
  assert(playerIndex > -1, "Player creature wasn't generated");
  if (playerIndex > 0)
    swap(&ret[playerIndex], &ret[0]);
  return move(ret);
}

export Game(int lineOfSight, vector<pair<vec2, LevelGenerator*>> generator,
    hash_map<string, GameObjectAttributes>* mapping) {
  mutable lastId = 0;
  mutable levels = vector<Level>();
  for (gen : generator) {
    const objects = generateObjects(gen.index, lastId, gen->first, gen->second, mapping);
    lastId = objects.back()->get()->id + 1;
    levels.push_back(Level("Level 1", gen->first, move(objects), vector<LevelAnimation>()));
  }
  return Game::Game(move(levels), 0, mapping, lineOfSight, null, lastId);
}

export int? walk(GameObject mutable* c, Game* g, double amount, double angle, double? facingDir) {
  c->lastWalkDirection = facingDir ?? angle;
  return c->advance(g, vec2d(sin(angle), cos(angle)) * amount * c->attributes.creature->speed);
}

int? advance(GameObject mutable* c, Game* g, vec2d dir) {
  c->pos += dir;
  if (c->attributes.creature)
    c->animation.lastMovement = current_time_milli();
  mutable int? ret = null;
  for (it : *g->getObjects())
    if (it->get() != c && !it->get()->projectile)
      if (const v = getRebound(c, it->get())) {
        c->pos -= *v;
        ret = it.index;
      }
  return ret;
}

bool woundCreature(Game mutable* g, int objIndex, int curTime, double damage) {
  const hitObject = (*g->getObjects())[objIndex].get();
  g->getLevel()->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime));
  if (hitObject->health)
    *hitObject->health -= damage;
  if (hitObject->health ?? 1.0 <= 0.0) {
    for (i : range(0, 10))
      g->getLevel()->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime + i));
    return true;
  }
  return false;
}

export void advance(Game mutable* g, double timeDiff) {
  mutable deadCreatures = vector<int>();
  mutable toAdd = vector<GameObject>();
  const curTime = current_time_milli();
  // Must iterate objects using an index as they may get killed and removed from the list.
  for (i = 0; i < g->getObjects()->size(); ++i)
    if (i > 0 && !!(*g->getObjects())[i]->attributes.creature)
      discard (*g->getObjects())[i]->attributes.creature->ai.makeMove(g, (*g->getObjects())[i].get(), timeDiff);
  for (it : *g->getObjects()) {
    const object = it->get();
    if (object->rangedAttackTimeout > 0.0)
      object->rangedAttackTimeout -= timeDiff;
    if (object->ongoingAttack) {
      object->ongoingAttack->remainingTime -= timeDiff;
      for (it2 : *g->getObjects())
        if (!object->ongoingAttack->woundedObjects.contains(&it2->get()->id)) {
          const object2 = it2->get();
          if (object2 != object && !!object2->attributes.creature && !!object2->attributes.box &&
              object2->attributes.box->isPenetrated(object->getMeleeWeaponPosition(null)->pos - object2->pos)) {
            object->ongoingAttack->woundedObjects.insert(object2->id);
            if (g->woundCreature(it2.index, curTime, object->ongoingAttack->attack.damage))
              deadCreatures.push_back(it2.index);
            break;
          }
        }
      if (object->ongoingAttack->remainingTime <= 0.0)
        object->ongoingAttack = null;
    }
    if (object->projectile) {
      const prevPos = object->pos;
      if (const targetIndex = object->advance(g, object->projectile->dir * timeDiff)) {
        deadCreatures.push_back(it.index);
        const target = (*g->getObjects())[*targetIndex].get();
        if (target->attributes.creature) {
          if (g->woundCreature(*targetIndex, curTime, object->projectile->damage))
            deadCreatures.push_back(*targetIndex);
        } else
          g->getLevel()->animations.push_back(LevelAnimation(LevelAnimationType::EXPLOSION, prevPos, curTime));
      }
    }
  }
  deadCreatures.sort(&[](int* a, int* b) { return *a > *b; });
  for (i = 0; i < deadCreatures.size(); ++i) {
    if (deadCreatures[i] == 0)
      g->status = GameStatus::GAME_LOST;
    else {
      const deadCreature = (*g->getObjects())[deadCreatures[i]].get();
      if (deadCreature->attributes.isEndGameBoss)
        g->status = GameStatus::GAME_WON;
      if (!!deadCreature->attributes.creature) {
        toAdd.push_back(GameObject(g->gameObjectIdCounter, deadCreature->pos,
            g->objectFactory->get(&"corpse")->copy()));
        toAdd.back()->attributes.glyph.size = deadCreature->attributes.glyph.size * 0.8;
      }
      g->getObjects()->remove(deadCreatures[i]);
    }
  }
  while (!toAdd.empty())
    g->getObjects()->push_back(toAdd.pop_back().box());
}

export bool addRangedAttack(Game mutable* game, GameObject mutable* o, mutable double direction) {
  if (o->rangedAttackTimeout <= 0.0 && !!o->attributes.creature && !!o->attributes.creature->rangedAttack) {
    const attack = &*o->attributes.creature->rangedAttack;
    direction += (get_random_d() - 0.5) * attack->inaccuracy;
    game->spawnProjectile(o, vec2d(sin(direction), cos(direction)) * attack->velocity,
        attack->glyph.randomizeColor(attack->colorVariance), attack->size, attack->damage);
    o->rangedAttackTimeout = attack->timeout;
    if (attack->extraTimeout) {
      ++o->rangedAttackProjectileCount;
      if (o->rangedAttackProjectileCount >= attack->extraTimeout->count) {
        o->rangedAttackTimeout = attack->extraTimeout->timeout;
        o->rangedAttackProjectileCount = 0;
      }
    }
    return true;
  }
  return false;
}

export void spawnProjectile(Game mutable *g, GameObject* o, vec2d dir, Glyph glyph, double size,
    double damage) {
  const vdir = dir / dir.length_d();
  g->getObjects()->push_back(GameObject(
      g->gameObjectIdCounter,
      o->pos + vdir * (size + o->attributes.box->size) / 2.0,
      GameObjectAttributes(
        move(glyph),
        "projectile",
        BoundingBox(size),
        null,
        false,
        null,
        false,
        false,
        false
      )
  ).box());
  g->getObjects()->back()->get()->projectile = Projectile(dir, damage);
}

export GameObject* getPlayer(Game* g) {
  return (*g->getObjects())[0].get();
}

export GameObject mutable* getPlayer(Game mutable* g) {
  return (*g->getObjects())[0].get();
}

