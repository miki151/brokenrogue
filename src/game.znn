
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "projectile.znn";
export import "table.znn";
export import "glyph.znn";
import "std/time.znn";
export import "level_generator.znn";
export import "std/hash_map.znn";
export import "level_animation.znn";
export import "game_object.znn";
import "ai.znn";
import "field_of_view.znn";

export struct Tile {
  Glyph glyph;
};

export Tile copy(Tile*) = default;

export struct Level {
  string name;
  table<Tile> tiles;
};

export Level(string name, vec2 size) {
  const tiles = table(size, Tile(Glyph(".", color(80, 80, 80))));
  return Level::Level(name, move(tiles));
}

export Tile*? getTile(Level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}

export enum GameStatus {
  GAME_LOST,
  GAME_WON
};

export struct Game {
  Level level;
  vector<box<GameObject>> objects;
  vector<LevelAnimation> animations;
  hash_map<string, GameObjectAttributes>* objectFactory;
  int lineOfSight;
  GameStatus? status;
  int gameObjectIdCounter;
};

export bool canSee(Game* game, GameObject mutable* obj, vec2 position) {
  const posInt = (obj->pos + vec2d(0.5, 0.5)).as_int();
  if (!obj->fovInfo || obj->fovInfo->origin != posInt) {
    obj->fovInfo = FOVInfo(
        posInt,
        table<int>(vec2(game->lineOfSight, game->lineOfSight), 0)
    );
    const getObjPos = [&](GameObject* obj2) { return obj->fovInfo->data.size() / 2 + obj2->pos.as_int() - posInt; };
    for (obj2 : game->objects)
      if (obj2->get()->attributes.blocksVision) {
        const opos = getObjPos(obj2->get());
        if (obj->fovInfo->data.bounds().contains(&opos))
          obj->fovInfo->data[opos] = 1;
      }
    obj->fovInfo->data = calculateFOV(&obj->fovInfo->data);
  }
  const vpos = position - posInt + obj->fovInfo->data.size() / 2;
  return obj->fovInfo->data.bounds().contains(&vpos) && obj->fovInfo->data[vpos] == 1;
}

export Game(int lineOfSight, LevelGenerator* generator, hash_map<string, GameObjectAttributes>* mapping) {
  const size = vec2(30, 30);
  const objects = getObjects(size, generator, mapping);
  const lastId = objects.back()->get()->id;
  return Game::Game(Level("Level 1", size), move(objects), vector<LevelAnimation>(),
      mapping, lineOfSight, null, lastId + 1);
}

export int? walk(GameObject mutable* c, Game* g, double amount, double angle, double? facingDir) {
  c->lastWalkDirection = facingDir ?? angle;
  return c->advance(g, vec2d(sin(angle), cos(angle)) * amount * c->attributes.creature->speed);
}

int? advance(GameObject mutable* c, Game* g, vec2d dir) {
  c->pos += dir;
  if (c->attributes.creature)
    c->animation.lastMovement = current_time_milli();
  mutable int? ret = null;
  for (it : g->objects)
    if (it->get() != c && !it->get()->projectile)
      if (const v = getRebound(c, it->get())) {
        c->pos -= *v;
        ret = it.index;
      }
  return ret;
}

bool woundCreature(Game mutable* g, int objIndex, int curTime, double damage) {
  const hitObject = g->objects[objIndex].get();
  g->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime));
  if (hitObject->health)
    *hitObject->health -= damage;
  if (hitObject->health ?? 1.0 <= 0.0) {
    for (i : range(0, 10))
      g->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime + i));
    return true;
  }
  return false;
}

export void advance(Game mutable* g, double timeDiff) {
  mutable deadCreatures = vector<int>();
  mutable toAdd = vector<GameObject>();
  const curTime = current_time_milli();
  // Must iterate objects using an index as they may get killed and removed from the list.
  for (i = 0; i < g->objects.size(); ++i)
    if (i > 0 && !!g->objects[i]->attributes.creature)
      discard g->objects[i]->attributes.creature->ai.makeMove(g, g->objects[i].get(), timeDiff);
  for (it : g->objects) {
    const object = it->get();
    if (object->rangedAttackTimeout > 0.0)
      object->rangedAttackTimeout -= timeDiff;
    if (object->ongoingAttack) {
      object->ongoingAttack->remainingTime -= timeDiff;
      for (it2 : g->objects)
        if (!object->ongoingAttack->woundedObjects.contains(&it2->get()->id)) {
          const object2 = it2->get();
          if (object2 != object && !!object2->attributes.creature && !!object2->attributes.box &&
              object2->attributes.box->isPenetrated(object->getMeleeWeaponPosition(null)->pos - object2->pos)) {
            object->ongoingAttack->woundedObjects.insert(object2->id);
            if (g->woundCreature(it2.index, curTime, object->ongoingAttack->attack.damage))
              deadCreatures.push_back(it2.index);
            break;
          }
        }
      if (object->ongoingAttack->remainingTime <= 0.0)
        object->ongoingAttack = null;
    }
    if (object->projectile) {
      const prevPos = object->pos;
      if (const targetIndex = object->advance(g, object->projectile->dir * timeDiff)) {
        deadCreatures.push_back(it.index);
        const target = g->objects[*targetIndex].get();
        if (target->attributes.creature) {
          if (g->woundCreature(*targetIndex, curTime, object->projectile->damage))
            deadCreatures.push_back(*targetIndex);
        } else
          g->animations.push_back(LevelAnimation(LevelAnimationType::EXPLOSION, prevPos, curTime));
      }
    }
  }
  deadCreatures.sort(&[](int* a, int* b) { return *a > *b; });
  for (i = 0; i < deadCreatures.size(); ++i) {
    if (deadCreatures[i] == 0)
      g->status = GameStatus::GAME_LOST;
    else {
      const deadCreature = g->objects[deadCreatures[i]].get();
      if (!!deadCreature->attributes.creature) {
        toAdd.push_back(GameObject(g->gameObjectIdCounter, deadCreature->pos,
            g->objectFactory->get(&"corpse")->copy()));
        toAdd.back()->attributes.glyph.size = deadCreature->attributes.glyph.size * 0.8;
      }
      g->objects.remove(deadCreatures[i]);
    }
  }
  const wonGame = [&] {
    for (it : g->objects)
      if (it.index > 0 && !!it->get()->attributes.creature)
        return false;
    return true;
  }();
  if (wonGame)
    g->status = GameStatus::GAME_WON;
  while (!toAdd.empty())
    g->objects.push_back(toAdd.pop_back().box());
}

export bool addRangedAttack(Game mutable* game, GameObject mutable* o, mutable double direction) {
  if (o->rangedAttackTimeout <= 0.0 && !!o->attributes.creature && !!o->attributes.creature->rangedAttack) {
    const attack = &*o->attributes.creature->rangedAttack;
    direction += (get_random_d() - 0.5) * attack->inaccuracy;
    game->spawnProjectile(o, vec2d(sin(direction), cos(direction)) * attack->velocity,
        attack->glyph.randomizeColor(attack->colorVariance), attack->size, attack->damage);
    o->rangedAttackTimeout = attack->timeout;
    if (attack->extraTimeout) {
      ++o->rangedAttackProjectileCount;
      if (o->rangedAttackProjectileCount >= attack->extraTimeout->count) {
        o->rangedAttackTimeout = attack->extraTimeout->timeout;
        o->rangedAttackProjectileCount = 0;
      }
    }
    return true;
  }
  return false;
}

export void spawnProjectile(Game mutable *g, GameObject* o, vec2d dir, Glyph glyph, double size,
    double damage) {
  const vdir = dir / dir.length_d();
  g->objects.push_back(GameObject(
      g->gameObjectIdCounter,
      o->pos + vdir * (size + o->attributes.box->size) / 2.0,
      GameObjectAttributes(
        move(glyph),
        "projectile",
        BoundingBox(size),
        null,
        false,
        null,
        false
      )
  ).box());
  g->objects.back()->get()->projectile = Projectile(dir, damage);
}

export GameObject* getPlayer(Game* g) {
  return g->objects[0].get();
}

export GameObject mutable* getPlayer(Game mutable* g) {
  return g->objects[0].get();
}

vector<box<GameObject>> getObjects(vec2 levelSize, LevelGenerator* generator,
    hash_map<string, GameObjectAttributes>* mapping) {
  mutable ret = vector<box<GameObject>>();
  const levelTable = *generator->generate(levelSize);
  mutable playerIndex = -1;
  for (v : levelTable.bounds())
    for (token : levelTable[*v])
      if (const attr = mapping->get_maybe(&*token)) {
        if (*token == "player") {
          assert(playerIndex == -1);
          playerIndex = ret.size();
        }
        ret.push_back(GameObject(ret.size(), v->as_double(), (*attr)->copy()).box());
      }
  if (playerIndex > 0)
    swap(&ret[playerIndex], &ret[0]);
  return move(ret);
}

