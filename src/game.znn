
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";
export import "color.znn";
export import "creature.znn";
export import "projectile.znn";
export import "table.znn";
export import "glyph.znn";
import "std/time.znn";
export import "level_generator.znn";
export import "std/hash_map.znn";
export import "level_animation.znn";
export import "game_object.znn";
import "ai.znn";
import "field_of_view.znn";

export struct Tile {
  Glyph glyph;
};

export Tile copy(Tile*) = default;

export struct Level {
  string name;
  table<Tile> tiles;
};

export Level(string name, vec2 size) {
  const tiles = table(size, Tile(Glyph(".", color(80, 80, 80))));
  return Level::Level(name, move(tiles));
}

export Tile*? getTile(Level* l, vec2 pos) {
  if (pos.x >= 0 && pos.x < l->tiles.size().x && pos.y >= 0 && pos.y < l->tiles.size().y)
    return &l->tiles[pos];
  return null;
}

export struct Game {
  Level level;
  vector<GameObject> objects;
  vector<LevelAnimation> animations;
  hash_map<string, GameObjectAttributes>* objectFactory;
  int lineOfSight;
  bool isOver;
};

export bool canSee(Game* game, GameObject mutable* obj, vec2 position) {
  const posInt = (obj->pos + vec2d(0.5, 0.5)).as_int();
  if (!obj->fovInfo || obj->fovInfo->origin != posInt) {
    obj->fovInfo = FOVInfo(
        posInt,
        table<int>(vec2(game->lineOfSight, game->lineOfSight), 0)
    );
    const getObjPos = [&](GameObject* obj2) { return obj->fovInfo->data.size() / 2 + obj2->pos.as_int() - posInt; };
    for (obj2 : game->objects)
      if (obj2->attributes.blocksVision) {
        const opos = getObjPos(&*obj2);
        if (obj->fovInfo->data.bounds().contains(&opos))
          obj->fovInfo->data[opos] = 1;
      }
    obj->fovInfo->data = calculateFOV(&obj->fovInfo->data);
  }
  const vpos = position - posInt + obj->fovInfo->data.size() / 2;
  return obj->fovInfo->data.bounds().contains(&vpos) && obj->fovInfo->data[vpos] == 1;
}

export Game(int lineOfSight, LevelGenerator* generator, hash_map<string, GameObjectAttributes>* mapping) {
  const size = vec2(30, 30);
  return Game::Game(Level("Level 1", size), getObjects(size, generator, mapping), vector<LevelAnimation>(),
      mapping, lineOfSight, false);
}

export int? walk(GameObject mutable* c, Game* g, double amount, double angle) {
  return c->advance(g, vec2d(sin(angle), cos(angle)) * amount * c->attributes.creature->speed);
}

int? advance(GameObject mutable* c, Game* g, vec2d dir) {
  c->pos += dir;
  if (c->attributes.creature)
    c->animation.lastMovement = current_time_milli();
  mutable int? ret = null;
  for (it : g->objects)
    if (&*it != c && !it->projectile)
      if (const v = getRebound(c, &*it)) {
        c->pos -= *v;
        ret = it.index;
      }
  return ret;
}

bool woundCreature(Game mutable* g, int objIndex, int curTime, double damage) {
  const hitObject = &g->objects[objIndex];
  g->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime));
  if (hitObject->health)
    *hitObject->health -= damage;
  if (hitObject->health ?? 1.0 <= 0.0) {
    for (i : range(0, 10))
      g->animations.push_back(LevelAnimation(LevelAnimationType::BLOOD, hitObject->pos, curTime + i));
    return true;
  }
  return false;
}

export void advance(Game mutable* g, double timeDiff) {
  mutable deadCreatures = vector<int>();
  mutable toAdd = vector<GameObject>();
  const curTime = current_time_milli();
  for (it : g->objects)
    if (it.index > 0 && !!it->attributes.creature)
      discard it->attributes.creature->ai.makeMove(g, &*it, timeDiff);
  for (it : g->objects) {
    if (it->rangedAttackTimeout > 0.0)
      it->rangedAttackTimeout -= timeDiff;
    if (it->ongoingAttack) {
      it->ongoingAttack->remainingTime -= timeDiff;
      if (!it->ongoingAttack->nullified)
        for (it2 : g->objects)
          if (it2 != it && !!it2->attributes.creature && !!it2->attributes.box &&
              it2->attributes.box->isPenetrated(it->pos + it->ongoingAttack->getPosition() - it2->pos)) {
            it->ongoingAttack->nullified = true;
            if (g->woundCreature(it2.index, curTime, it->ongoingAttack->attack.damage))
              deadCreatures.push_back(it2.index);
            break;
          }
      if (it->ongoingAttack->remainingTime <= 0.0)
        it->ongoingAttack = null;
    }
    if (it->projectile) {
      const prevPos = it->pos;
      if (const targetIndex = it->advance(g, it->projectile->dir * timeDiff)) {
        deadCreatures.push_back(it.index);
        const target = &g->objects[*targetIndex];
        if (target->attributes.creature) {
          if (g->woundCreature(*targetIndex, curTime, it->projectile->damage))
            deadCreatures.push_back(*targetIndex);
        } else
          g->animations.push_back(LevelAnimation(LevelAnimationType::EXPLOSION, prevPos, curTime));
      }
    }
  }
  deadCreatures.sort(&[](int* a, int* b) { return *a > *b; });
  for (i = 0; i < deadCreatures.size(); ++i) {
    if (deadCreatures[i] == 0)
      g->isOver = true;
    else {
      if (!!g->objects[deadCreatures[i]].attributes.creature)
        toAdd.push_back(GameObject(g->objects[deadCreatures[i]].pos, g->objectFactory->get(&"corpse")->copy()));
      g->objects.remove(deadCreatures[i]);
    }
  }
  while (!toAdd.empty())
    g->objects.push_back(toAdd.pop_back());
}

export bool addRangedAttack(Game mutable* game, GameObject mutable* o, mutable double direction) {
  if (o->rangedAttackTimeout <= 0.0 && !!o->attributes.creature && !!o->attributes.creature->rangedAttack) {
    const attack = &*o->attributes.creature->rangedAttack;
    direction += (get_random_d() - 0.5) * attack->inaccuracy;
    mutable glyph = attack->glyph.copy();
    game->spawnProjectile(o, vec2d(sin(direction), cos(direction)) * attack->velocity,
        attack->glyph.randomizeColor(attack->colorVariance), attack->size, attack->damage);
    o->rangedAttackTimeout = attack->timeout;
    if (attack->extraTimeout) {
      ++o->rangedAttackProjectileCount;
      if (o->rangedAttackProjectileCount >= attack->extraTimeout->count) {
        o->rangedAttackTimeout = attack->extraTimeout->timeout;
        o->rangedAttackProjectileCount = 0;
      }
    }
    return true;
  }
  return false;
}

export void spawnProjectile(Game mutable *g, GameObject* o, vec2d dir, Glyph glyph, double size,
    double damage) {
  const vdir = dir / dir.length_d();
  g->objects.push_back(GameObject(
      o->pos + vdir * (size + o->attributes.box->size) / 2.0,
      GameObjectAttributes(
        move(glyph),
        BoundingBox(size),
        null,
        false,
        null,
        false
      )
  ));
  g->objects.back()->projectile = Projectile(dir, damage);
}

export GameObject* getPlayer(Game* g) {
  return &g->objects[0];
}

export GameObject mutable* getPlayer(Game mutable* g) {
  return &g->objects[0];
}

vector<GameObject> getObjects(vec2 levelSize, LevelGenerator* generator,
    hash_map<string, GameObjectAttributes>* mapping) {
  mutable ret = vector<GameObject>();
  const levelTable = *generator->generate(levelSize);
  mutable playerIndex = -1;
  for (v : levelTable.bounds())
    for (token : levelTable[*v])
      if (const attr = mapping->get_maybe(&*token)) {
        if (*token == "player") {
          assert(playerIndex == -1);
          playerIndex = ret.size();
        }
        ret.push_back(GameObject(v->as_double(), (*attr)->copy()));
      }
  if (playerIndex > 0)
    swap(&ret[playerIndex], &ret[0]);
  return move(ret);
}

