
export import "color.znn";
export import "ui_canvas.znn";
import "std/range.znn";
import "std/math.znn";
import "std/io.znn";
import "std/random.znn";

export struct StackInfo {
  int count;
  int height;
  int colorDiff;
};

export StackInfo copy(StackInfo*) = default;

export struct Glyph {
  string sym;
  color col;
  double size;
  StackInfo? stackInfo;
};

export Glyph(string, color, double, StackInfo?) = default;

export Glyph(string c, color col, double s) {
  return Glyph(c, col, s, null);
}

export Glyph(string c, color col) {
  return Glyph(c, col, 1.0);
}

export Glyph copy(Glyph*) = default;

export Glyph randomizeColor(Glyph* g, int variance) {
  mutable ret = g->copy();
  if (variance > 0) {
    ret.col.r = max(0, min(255, ret.col.r + get_random(variance + 1) - variance / 2));
    ret.col.g = max(0, min(255, ret.col.g + get_random(variance + 1) - variance / 2));
    ret.col.b = max(0, min(255, ret.col.b + get_random(variance + 1) - variance / 2));
  }
  return move(ret);
}

export void render(Glyph* g, UICanvas* canvas, int font_size, vec2 pos) {
  assert(!g->stackInfo, "Tried to render stacked glyph without given angle");
  canvas->drawText(pos, g->sym, (g->size * font_size).as_int(), &g->col, ui_text_flag::CENTER_XY);
}

export void render(Glyph* g, UICanvas* canvas, int font_size, vec2 pos, double angle) {
  if (g->stackInfo)
    for (i : range(0, g->stackInfo->count)) {
      mutable col = g->col;
      col.r += i * g->stackInfo->colorDiff;
      col.g += i * g->stackInfo->colorDiff;
      col.b += i * g->stackInfo->colorDiff;
      canvas->drawRotatedText(pos - vec2(0, i * g->stackInfo->height), g->sym,
          (g->size * font_size).as_int(), &col, angle);
    }
  else
    canvas->drawText(pos, g->sym, (g->size * font_size).as_int(), &g->col, ui_text_flag::CENTER_XY);
}

export void renderRotated(Glyph* g, UICanvas* canvas, int font_size, vec2 pos, double angle) {
  canvas->drawRotatedText(pos, g->sym, (g->size * font_size).as_int(), &g->col, angle);
}
