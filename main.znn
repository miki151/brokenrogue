

import "sdl.znn";
import "sdl_surface.znn";
import "sdl_canvas.znn";
import "ui.znn";
import "std/io.znn";
import "ui_reader.znn";
import "sdl_ttf.znn";
import "ui_data.znn";
import "game.znn";
import "std/enum_set.znn";
import "std/enum.znn";
import "std/time.znn";
import "std/flags.znn";

struct Y {
  int u;
};

struct X {
  int a;
  bool b;
  Y y;
};

hash_map<string, sdl_texture> load_textures(sdl_window* window) {
  mutable ret = hash_map<string, sdl_texture>();
//  ret.insert("tex1", *sdl_load_bmp("texture1.bmp")->to_texture(window));
  return move(ret);
}

box<ui_element> read_ui_from(string path) {
  const file = *open_file_r(path);
  const content = *file.read_content();
  return *read_ui(move(content));
}

struct Flags {
  string? font_path;
};

int main(string[] args) {
  const flags = *read_flags<Flags>(args);
  *sdl_init();
  mutable ui = read_ui_from("ui.txt");
  const window = *sdl_create_window(vec2(1280, 720), "Infinihack");
  *sdl_set_relative_mouse_mode(true);
  const font = *window.load_sdl_font(flags.font_path ?? "font.ttf", 50);
  const canvas = sdl_canvas(&window, &font, load_textures(&window));
  const ui_rectangle = rectangle(vec2(0, 0), window.size());
  mutable game1 = game();
  mutable ui_data = ui_record(hash_map<string, box<any>>());
  ui_data.data.insert("game_level", box_as<any, game*>(&game1));
  mutable exit = false;
  mutable diff_time = 0.0;
  ui_data.data.insert("exit_callback", [&exit] { exit = true; }.box_as<ui_callback>().box_as<any>());
  ui_data.data.insert("reload_ui", [&ui] { ui = read_ui_from("ui.txt"); }.box_as<ui_callback>().box_as<any>());
  ui_data.data.insert("player_forward",
      [&game1, &diff_time] { game1.get_player()->advance(&game1, 4 * diff_time, 0); }.box_as<ui_callback>().box_as<any>());
  ui_data.data.insert("player_back",
      [&game1, &diff_time] { game1.get_player()->advance(&game1, -4 * diff_time, 0); }.box_as<ui_callback>().box_as<any>());
  ui_data.data.insert("player_left",
      [&game1, &diff_time] { game1.get_player()->advance(&game1, 2 * diff_time, 1.57); }.box_as<ui_callback>().box_as<any>());
  ui_data.data.insert("player_right",
      [&game1, &diff_time] { game1.get_player()->advance(&game1, -2 * diff_time, 1.57); }.box_as<ui_callback>().box_as<any>());
  mutable last_update = current_time_milli();
  mutable events_state = sdl_events_state();
  while (!exit) {
    const cur_time = current_time_milli();
    diff_time = 0.001 * (cur_time - last_update);
    last_update = cur_time;
    for (event : events_state.get_events()) {
      if (exit)
        break;
      switch (*event) {
        case (quit) { return 0; }
        case (key) {
          discard ui->on_key_event(&canvas, &ui_data, &ui_rectangle, &key);
        }
        case (mouse) {
          if (mouse.type == mouse_event_type::LEFT)
            discard ui->on_mouse_event(&canvas, &ui_data, &ui_rectangle, &mouse);
          if (mouse.type == mouse_event_type::RELATIVE_MOTION)
            game1.get_player()->dir -= 0.0008 * mouse.pos.x;
        }
        default {}
      }
    }
    ui->render(&canvas, &ui_data, &ui_rectangle);
    window.update();
  }
  return 0;
}
