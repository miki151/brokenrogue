

import "sdl.znn";
import "sdl_surface.znn";
import "sdl_canvas.znn";
import "ui.znn";
import "std/io.znn";
import "ui_reader.znn";
import "sdl_ttf.znn";
import "ui_data.znn";
import "game.znn";

struct Y {
  int u;
};

struct X {
  int a;
  bool b;
  Y y;
};

hash_map<string, sdl_texture> load_textures(sdl_window* window) {
  mutable ret = hash_map<string, sdl_texture>();
  ret.insert("tex1", *sdl_load_bmp("texture1.bmp")->to_texture(window));
  return move(ret);
}

box<ui_element> read_ui_from(string path) {
  const file = *open_file_r(path);
  const content = *file.read_content();
  return *read_ui(move(content));
}

int main() {
  *sdl_init();
  mutable ui = read_ui_from("ui.txt");
  const window = *sdl_create_window(vec2(640, 480), "Infinihack");
  const font = *load_sdl_font("font.ttf", 20);
  const canvas = sdl_canvas(&window, &font, load_textures(&window));
  const ui_rectangle = rectangle(vec2(0, 0), window.size());
  mutable game1 = game();
  mutable ui_data = ui_record(hash_map<string, box<any>>());
  ui_data.data.insert("game_level", box_as<any, level*>(&game1.level));
  mutable exit = false;
  const exit_callback = [&exit] { exit = true; };
  ui_data.data.insert("exit_callback", ui_callback(&exit_callback).box_as<any>());
  while (!exit) {
    for (event = SDLPollEvent(); !!event; event = SDLPollEvent()) {
      if (exit)
        break;
      switch (*event) {
        case (quit) { return 0; }
        case (key) {
          switch (key.key) {
            case (ESCAPE) { return 0; }
            case (UP) { ui = read_ui_from("ui.txt"); }
            default {}
          }
        }
        case (mouse) { discard ui->on_mouse_event(&canvas, &ui_data, &ui_rectangle, &mouse); }
        default {}
      }
    }
    ui->render(&canvas, &ui_data, &ui_rectangle);
    window.update();
  }
  return 0;
}
