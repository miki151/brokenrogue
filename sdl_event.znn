
embed {
#include "SDL.h"
}

export import "std/expected.znn";
export import "std/vector.znn";
export import "vec2.znn";
export import "ui_event.znn";
export import "std/enum_set.znn";
import "std/enum.znn";


export struct SDLQuitEvent {
};


export struct SDLUnknownEvent {
};

export union SDLEvent {
  SDLQuitEvent quit;
  key_event key;
  mouse_event mouse;
  SDLUnknownEvent unknown;
};

export void!string sdl_set_relative_mouse_mode(bool state) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    if (SDL_SetRelativeMouseMode(state ? SDL_TRUE : SDL_FALSE) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError())); 
  }
}

export struct sdl_events_state {
  enum_set<key_type> pressed_keys;
  vec2 leftJostickState;
  vec2 rightJostickState;
};

export sdl_events_state() {
  return sdl_events_state::sdl_events_state(enum_set<key_type>(), vec2(0, 0), vec2(0, 0));
}

export vector<SDLEvent> get_events(sdl_events_state mutable* state) {
  mutable ret = vector<SDLEvent>();
  const update_key = [&] (key_type k, bool s) {
    state->pressed_keys.set(k, s);
  };
  embed {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
      auto get = [&] {
        auto get_event = [&](key_type key, bool down) {
          invoke(&update_key, key, down);
          return SDLEvent::key(key_event{key, down ? key_event_type::DOWN : key_event_type::UP});
        };
        if (event.type == SDL_JOYBUTTONDOWN || event.type == SDL_JOYBUTTONUP) {
          bool down = event.type == SDL_JOYBUTTONDOWN;
          switch (event.jbutton.button) {
            case 8:  return get_event(key_type::W, down);
            case 4:
            case 10: return get_event(key_type::Y, down);
            case 5:
            case 11: return get_event(key_type::F1, down);
            case 9:  return get_event(key_type::S, down);
            case 2:  return get_event(key_type::ESCAPE, down);
            case 0:  return get_event(key_type::B, down);
            case 3:  return get_event(key_type::Y, down);
            case 1:  return get_event(key_type::ENTER, down);
          }
        }
        if (event.type == SDL_QUIT)
          return SDLEvent::quit(SDLQuitEvent{});
        if (event.type == SDL_KEYDOWN || event.type == SDL_KEYUP) {
          bool down = event.type == SDL_KEYDOWN;
          switch (event.key.keysym.sym) {
            case SDLK_UP:    return get_event(key_type::UP, down);
            case SDLK_LEFT:  return get_event(key_type::LEFT, down);
            case SDLK_RIGHT: return get_event(key_type::RIGHT, down);
            case SDLK_DOWN:  return get_event(key_type::DOWN, down);
            case SDLK_ESCAPE:return get_event(key_type::ESCAPE, down);
            case SDLK_SPACE: return get_event(key_type::SPACE, down);
            case SDLK_RETURN:return get_event(key_type::ENTER, down);
            case SDLK_F1:    return get_event(key_type::F1, down);
            case SDLK_a:     return get_event(key_type::A, down);
            case SDLK_w:     return get_event(key_type::W, down);
            case SDLK_s:     return get_event(key_type::S, down);
            case SDLK_d:     return get_event(key_type::D, down);
            case SDLK_b:     return get_event(key_type::B, down);
            case SDLK_y:     return get_event(key_type::Y, down);
            default: break;
          }
        }
        if (event.type == SDL_MOUSEMOTION) {
          return SDLEvent::mouse({mouse_event_type::JOYSTICK_RIGHT, {event.motion.xrel * 40, 0}});
        }
        if (event.type == SDL_JOYAXISMOTION) {
          int value = event.jaxis.value / 33;
          switch (event.jaxis.axis) {
            case 0: state->leftJostickState.x = value; break;
            case 1: state->leftJostickState.y = value; break;
            case 2: state->rightJostickState.x = value; break;
            case 3: state->rightJostickState.y = value; break;
          }
        }
        if (event.type == SDL_MOUSEBUTTONDOWN) {
          mouse_event_type button = mouse_event_type::LEFT;
          switch (event.button.button) {
            case SDL_BUTTON_LEFT:
              button = mouse_event_type::LEFT;
              break;
            case SDL_BUTTON_RIGHT:
              button = mouse_event_type::RIGHT;
              break;
            case SDL_BUTTON_MIDDLE:
              button = mouse_event_type::MIDDLE;
              break;
          }
          return SDLEvent::mouse(mouse_event{ button, vec2{event.button.x, event.button.y} });
        }
        return SDLEvent::unknown(SDLUnknownEvent{});
      };
      ret.push_back(get());
    }
  }
  for (e : enum_range<key_type>())
    if (state->pressed_keys.contains(*e))
      ret.push_back(SDLEvent::key(key_event(*e, key_event_type::HELD)));
  ret.push_back(SDLEvent::mouse((mouse_event(mouse_event_type::JOYSTICK_LEFT, state->leftJostickState))));
  ret.push_back(SDLEvent::mouse((mouse_event(mouse_event_type::JOYSTICK_RIGHT, state->rightJostickState))));
  return move(ret);
}



