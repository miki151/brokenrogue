
export import "std/expected.znn";
export import "color.znn";
export import "vec2.znn";
export import "rectangle.znn";

import "std/io.znn";

embed {
#include "SDL.h"
}

export embed {
  struct SDL_Surface;
}

extern struct SDL_Surface;

export struct sdl_surface {
  SDL_Surface mutable* surface;
};

export enum SDLTransformType {
  NONE,
  ROTATE_LEFT,
  MIRROR_HOR
};

export color getPixel(sdl_surface* source, vec2 pos) {
  embed_returns {
  auto surface = source->surface;
  auto get = [&]() -> Uint32 {
    int bpp = surface->format->BytesPerPixel;
    Uint8 *p = (Uint8 *)surface->pixels + pos.y * surface->pitch + pos.x * bpp;
    switch (bpp) {
      case 1:
        return *p;
      case 2:
        return *(Uint16*)p;
      case 3:
        if (SDL_BYTEORDER == SDL_BIG_ENDIAN)
          return p[0] << 16 | p[1] << 8 | p[2];
        else
          return p[0] | p[1] << 8 | p[2] << 16;
      case 4:
        return *(Uint32 *)p;
      default:
        return 0; 
    }
  };
  Uint8 r, g, b;
  SDL_GetRGB(get(), surface->format, &r, &g, &b);
  return color{r, g, b};
  }
}

export void setPixel(sdl_surface* source, vec2 pos, color col) {
  embed {
  auto surface = source->surface;
  auto set = [&](Uint32 value) {
    int bpp = surface->format->BytesPerPixel;
    Uint8 *p = (Uint8 *)surface->pixels + pos.y * surface->pitch + pos.x * bpp;
    switch (bpp) {
      case 1:
        *p = value;
      case 2:
        *(Uint16*)p = value;
      case 3:
        p[0] = col.r;
        p[1] = col.g;
        p[2] = col.b;
      case 4:
        *(Uint32 *)p = value;
      default:
        return 0; 
    }
  };
  set(SDL_MapRGB(surface->format, col.r, col.g, col.b));
  }
}

export expected<sdl_surface, string> createSurface(vec2 size) {
  const getResult = [](SDL_Surface mutable* s) -> expected<sdl_surface, string> {
    return sdl_surface(s);
  };
  const getError = [](string s) -> expected<sdl_surface, string> {
    return s;
  };
  embed_returns {
    auto surface = SDL_CreateRGBSurface(0, size.x, size.y, 32, 0, 0, 0, 0);
    if (!surface)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    return invoke(&getResult, surface);
  }
}

export expected<sdl_surface, string> transform(sdl_surface* source, SDLTransformType transformType) {
  const getResult = [](SDL_Surface mutable* s) -> expected<sdl_surface, string> {
    return sdl_surface(s);
  };
  const getError = [](string s) -> expected<sdl_surface, string> {
    return s;
  };
  embed_returns {
    auto surface = SDL_ConvertSurface(source->surface, source->surface->format, 0);
    if (!surface)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
    Uint8* sourcePixels = (Uint8*)source->surface->pixels;
    Uint8* targetPixels = (Uint8*)surface->pixels;
    if (transformType != SDLTransformType::NONE) {
      SDL_LockSurface(surface);
      for (int x = 0; x < source->surface->w; ++x)
        for (int y = 0; y < source->surface->h; ++y)
          for (int b = 0; b < 4; ++b) {
            auto sourcePos = vec2{y, surface->w - x - 1};
            if (transformType == SDLTransformType::MIRROR_HOR)
              sourcePos = vec2{sourcePos.y, sourcePos.x};
            targetPixels[y * surface->pitch + x * sizeof(Uint32) + b] =
              sourcePixels[sourcePos.y * source->surface->pitch + sourcePos.x * sizeof(Uint32) + b];
          }
      SDL_UnlockSurface(surface);
    }
    return invoke(&getResult, surface);
  }
}

export vec2 size(sdl_surface* s) {
  embed_returns {
    return vec2{s->surface->w, s->surface->h};
  }
}

export sdl_surface!string sdl_load_bmp(string path) {
  const getResult = [](SDL_Surface mutable* s) -> sdl_surface!string {
    return sdl_surface(s);
  };
  const getError = [](string s) -> sdl_surface!string {
    return s;
  };
  embed_returns {
    if (auto res = SDL_LoadBMP(path.data()))
      return invoke(&getResult, res);
    else
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}

export string? clear(sdl_surface* s, color color) {
  embed {
    if (SDL_FillRect(s->surface, nullptr, SDL_MapRGB(s->surface->format, color.r, color.g, color.b)) != 0)
      return zenon_string::reference(SDL_GetError());
  }
  return null;
}

export void!string filled_rectangle(sdl_surface* s, rectangle* rect, color color) {
  const getError = [](string s) -> void!string {
    return s;
  };
  embed {
    SDL_Rect sdlRect;
    sdlRect.x = rect->v1.x;
    sdlRect.y = rect->v1.y;
    sdlRect.w = rect->v2.x - rect->v1.x;
    sdlRect.h = rect->v2.y - rect->v1.y;
    if (SDL_FillRect(s->surface, &sdlRect, SDL_MapRGB(s->surface->format, color.r, color.g, color.b)) != 0)
      return invoke(&getError, zenon_string::reference(SDL_GetError()));
  }
}


