
export import "std/expected.znn";
export import "std/vector.znn";
export import "vec2.znn";
export import "rectangle.znn";
export import "color.znn";
export import "ui_canvas.znn";
export import "ui_event.znn";
import "ui_data.znn";
export import "std/math.znn";
export import "std/any.znn";
export import "std/io.znn";
export import "std/box.znn";
export import "ui_state.znn";

export struct ui_context {
  ui_canvas* canvas;
  any* data;
  ui_state mutable* state;
  double time_diff;
};

export ui_context implicit_copy(ui_context*) = default;

export concept<T> ui_element {
  void render(T*, ui_context, rectangle*);
  vec2 size(T*, ui_context);
  bool on_key_event(T*, ui_context, rectangle*, key_event*);
  bool on_mouse_event(T*, ui_context, rectangle*, mouse_event*);
  void destruct(T*);
};

export concept<T> container_ui {
  box<ui_element>[] get_elems(T*);
  rectangle get_bounds(T*, int index, ui_context, rectangle* bounds);
  any*!string transform_data(T*, any*);
};

export attribute @ui_element;

export template <T> requires has_attribute<T, @ui_element>
void render(T*, ui_context, rectangle*) {}

export template <T> requires has_attribute<T, @ui_element>
vec2 size(T*, ui_context) {
  return vec2(0, 0);
}

export template <T> requires has_attribute<T, @ui_element>
bool on_key_event(T*, ui_context, rectangle*, key_event*) {
  return false;
}

export template <T> requires has_attribute<T, @ui_element>
bool on_mouse_event(T*, ui_context, rectangle*, mouse_event*) {
  return false;
}

export template <T>
any*!string transform_data(T*, any* a) {
  return a;
}

export template <T> requires container_ui<T>
void render(T* t, mutable ui_context context, rectangle* r) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    for (elem : t->get_elems())
      elem->get()->render(context, &t->get_bounds(elem.index, context, r));
  } else
    context.canvas->draw_text(r->v1, data.get_error(), 10, &color(255, 0, 0));
}

export template <T> requires container_ui<T>
vec2 size(T* t, ui_context context) {
  mutable ret = vec2(0, 0);
  for (elem : t->get_elems()) {
    const sz = elem->get()->size(context);
    ret.x = max(ret.x, sz.x);
    ret.y = max(ret.y, sz.y);
  }
  return ret;
}

export template <T> requires container_ui<T>
bool on_key_event(T* t, mutable ui_context context, rectangle* r, key_event* key) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    for (elem : t->get_elems())
      if (elem->get()->on_key_event(context, r, key))
        return true;
  }
  return false;
}

export template <T> requires container_ui<T>
bool on_mouse_event(T* t, mutable ui_context context, rectangle* r, mouse_event* m) {
  if (const data = t->transform_data(context.data)) {
    context.data = *data;
    for (elem : t->get_elems())
      if (elem->get()->on_mouse_event(context, &t->get_bounds(elem.index, context, r), m))
        return true;
  }
  return false;
}

export [@ui_element]
struct texture {
  string id;
  texture_flip flip;
};

export void render(texture* t, ui_context context, rectangle* r) {
  context.canvas->draw_texture(r, t->id, texture_flip::NONE);
}

export vec2 size(texture* t, ui_context context) {
  return context.canvas->get_texture_size(t->id);
}

export [@ui_element]
struct button {
};

export bool on_mouse_event(button* b, ui_context context, rectangle* r, mouse_event* event) {
  if (event->type == mouse_event_type::LEFT && r->contains(&event->pos))
    if (const callback = context.data->cast_to<box<ui_callback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

export [@ui_element]
struct label {
  string text;
  int size;
  color color;
};

export void render(label* t, ui_context context, rectangle* r) {
  context.canvas->draw_text(r->v1, t->text, t->size, &t->color);
}

export vec2 size(label* t, ui_context context) {
  return context.canvas->get_text_size(t->text, t->size);
}

export [@ui_element]
struct text_ui {
  int size;
  color color;
};

export void render(text_ui* t, ui_context context, rectangle* r) {
  if (const s = context.data->cast_to<string>())
    context.canvas->draw_text(r->v1, **s, t->size, &t->color);
}

export vec2 size(text_ui* t, ui_context context) {
  return context.canvas->get_text_size("something", t->size);
}

export [@ui_element]
struct fill {
  color color;
};

export void render(fill* t, ui_context context, rectangle* r) {
  context.canvas->fill_rectangle(r, &t->color);
}

export [@ui_element]
struct frame {
  int width;
  color color;
};

export void render(frame* t, ui_context context, rectangle* r) {
  context.canvas->frame_rectangle(r, &t->color, t->width);
}

export struct chain {
  vector<box<ui_element>> elems;
};

export box<ui_element>[] get_elems(chain* c) {
  return c->elems.slice();
}

export rectangle get_bounds(chain* c, int, ui_context, rectangle* r) {
  return r->copy();
}

export struct margins {
  int width;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(margins* m) {
  return singleton_slice(&m->elem);
}

export rectangle get_bounds(margins* c, int, ui_context, rectangle* r) {
  return r->plus_margin(-c->width);
}

export vec2 size(margins* t, ui_context context) {
  return t->elem->size(context) + vec2(t->width, t->width) * 2;
}

export enum position_enum {
  CENTER,
  TOP_CENTER,
};

export struct position {
  position_enum pos;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(position* p) {
  return singleton_slice(&p->elem);
}

export rectangle get_bounds(position* p, int ind, ui_context context, rectangle* r) {
  const size = p->elem->size(context);
  switch (p->pos) {
    case (CENTER) { return rectangle(r->middle() - size / 2, r->middle() + size / 2); }
    case (TOP_CENTER) { return rectangle(
        vec2(r->middle().x - size.x / 2, r->top()),
        vec2(r->middle().x + size.x / 2, r->top() + size.y)); }
  }
}

export enum list_ui_type {
  HORIZONTAL,
  VERTICAL,
};

export [@ui_element]
struct list_ui {
  list_ui_type type;
  vector<box<ui_element>> elems;
};

vector<rectangle> get_elem_positions(list_ui* t, ui_context context, rectangle* r) {
  mutable ret = vector<rectangle>();
  mutable start = 0;
  for (it : t->elems)
    switch (t->type) {
      case (VERTICAL) {
        const height = it->get()->size(context).y;
        ret.push_back(rectangle(vec2(r->left(), r->top() + start),
            vec2(r->right(), r->top() + start + height)));
        start += height;
      }
      case (HORIZONTAL) {
        const width = it->get()->size(context).x;
        ret.push_back(rectangle(vec2(r->left() + start, r->top()),
            vec2(r->right() + start + width, r->bottom())));
        start += width;
      }
    }
  return move(ret);
}

export bool on_mouse_event(list_ui* c, ui_context context, rectangle* rect,
    mouse_event* event) {
  const positions = get_elem_positions(c, context, rect);
  for (it : c->elems)
    if (it->get()->on_mouse_event(context, &positions[it.index], event))
      return true;
  return false;
}

export void render(list_ui* t, ui_context context, rectangle* r) {
  const positions = get_elem_positions(t, context, r);
  for (it : t->elems)
    it->get()->render(context, &positions[it.index]);
}

export vec2 size(list_ui* t, ui_context context) {
  mutable ret = vec2(0, 0);
  for (it : t->elems) {
    const sz = it->get()->size(context);
    switch (t->type) {
      case (VERTICAL) {
        ret.y += sz.y;
        ret.x = max(ret.x, sz.x);
      }
      case (HORIZONTAL) {
        ret.x += sz.x;
        ret.y = max(ret.y, sz.y);
      }
    }
  }
  return ret;
}

export struct using_ui {
  string key;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(using_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(using_ui* c, int, ui_context, rectangle* r) {
  return r->copy();
}

export any*!string transform_data(using_ui* u, any* a) {
  if (const r = a->cast_to<ui_record>()) {
    if (const res = (*r)->data.get_maybe(&u->key))
      return (*res)->get();
    return "{u->key}: record key not found in data.";
  } else
    return "Bad UI data: not a record: {a->get_type()}";
}

export struct width_ui {
  int width;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(width_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(width_ui* c, int, ui_context, rectangle* r) {
  return r->copy();
}

export vec2 size(width_ui* t, ui_context context) {
  return vec2(t->width, t->elem->size(context).y);
}

export struct height_ui {
  int height;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(height_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(height_ui* c, int, ui_context, rectangle* r) {
  return r->copy();
}

export vec2 size(height_ui* t, ui_context context) {
  return vec2(t->elem->size(context).x, t->height);
}

export [@ui_element]
struct key_handler {
  key_event event;
};

export bool on_key_event(key_handler* k, ui_context context, rectangle* rect, key_event* event) {
  if (*event == k->event)
    if (const callback = context.data->cast_to<box<ui_callback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

