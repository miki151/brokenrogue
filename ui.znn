
export import "std/expected.znn";
export import "std/vector.znn";
export import "vec2.znn";
export import "rectangle.znn";
export import "color.znn";
export import "ui_canvas.znn";
export import "ui_event.znn";
import "ui_data.znn";
export import "std/math.znn";
export import "std/any.znn";
export import "std/io.znn";
export import "std/box.znn";

export concept<T> ui_element {
  void render(T*, ui_canvas*, any*, rectangle*);
  vec2 size(T*, ui_canvas*);
  bool on_key_event(T*, ui_canvas*, any*, rectangle*, key_event*);
  bool on_mouse_event(T*, ui_canvas*, any*, rectangle*, mouse_event*);
  void destruct(T*);
};

export concept<T> container_ui {
  box<ui_element>[] get_elems(T*);
  rectangle get_bounds(T*, int index, ui_canvas*, rectangle* bounds);
  any*!string transform_data(T*, any*);
};

export attribute @ui_element;

export template <T> requires has_attribute<T, @ui_element>
void render(T*, ui_canvas*, any*, rectangle*) {}

export template <T> requires has_attribute<T, @ui_element>
vec2 size(T*, ui_canvas*) {
  return vec2(0, 0);
}

export template <T> requires has_attribute<T, @ui_element>
bool on_key_event(T*, ui_canvas*, any*, rectangle*, key_event*) {
  return false;
}

export template <T> requires has_attribute<T, @ui_element>
bool on_mouse_event(T*, ui_canvas*, any*, rectangle*, mouse_event*) {
  return false;
}

export template <T>
any*!string transform_data(T*, any* a) {
  return a;
}

export concept<T, D> render_with_data {
  void render(T*, ui_canvas*, D*, rectangle*);
};

export template <T, D> requires render_with_data<T, D>, (!(D == any))
void render(T* t, ui_canvas* canvas, any* any_data, rectangle* r) {
  if (const data = any_data->cast_to<D>())
    render(t, canvas, *data, r);
  else
    canvas->draw_text(r->v1, "{any_data->get_type()}, expected: {to_string(D)}", &color(255, 0, 0));
}

export template <T> requires container_ui<T>
void render(T* t, ui_canvas* canvas, any* any, rectangle* r) {
  if (const data = t->transform_data(any)) {
    for (elem : t->get_elems())
      elem->get()->render(canvas, *data, &t->get_bounds(elem.index, canvas, r));
  } else
    canvas->draw_text(r->v1, data.get_error(), &color(255, 0, 0));
}

export template <T> requires container_ui<T>
vec2 size(T* t, ui_canvas* canvas) {
  mutable ret = vec2(0, 0);
  for (elem : t->get_elems()) {
    const sz = elem->get()->size(canvas);
    ret.x = max(ret.x, sz.x);
    ret.y = max(ret.y, sz.y);
  }
  return ret;
}

export template <T> requires container_ui<T>
bool on_key_event(T* t, ui_canvas* canvas, any* any, rectangle* r, key_event* key) {
  printf("key event\n");
  if (const data = t->transform_data(any))
    for (elem : t->get_elems())
      if (elem->get()->on_key_event(canvas, *data, r, key))
        return true;
  return false;
}

export template <T> requires container_ui<T>
bool on_mouse_event(T* t, ui_canvas* canvas, any* any, rectangle* r, mouse_event* m) {
  if (const data = t->transform_data(any))
    for (elem : t->get_elems())
      if (elem->get()->on_mouse_event(canvas, *data, &t->get_bounds(elem.index, canvas, r), m))
        return true;
  return false;
}

export [@ui_element]
struct texture {
  string id;
  texture_flip flip;
};

export void render(texture* t, ui_canvas* canvas, any* any, rectangle* r) {
  canvas->draw_texture(r, t->id, texture_flip::NONE);
}

export vec2 size(texture* t, ui_canvas* canvas) {
  return canvas->get_texture_size(t->id);
}

export [@ui_element]
struct button {
};

export bool on_mouse_event(button* b, ui_canvas*, any* data, rectangle* rect, mouse_event* event) {
  if (rect->contains(&event->pos))
    if (const callback = data->cast_to<box<ui_callback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

export [@ui_element]
struct label {
  string? text;
  color color;
};

export void render(label* t, ui_canvas* canvas, any* any, rectangle* r) {
  canvas->draw_text(r->v1, t->text ?? "something", &t->color);
}

export vec2 size(label* t, ui_canvas* canvas) {
  return canvas->get_text_size(t->text ?? "something");
}

export [@ui_element]
struct fill {
  color color;
};

export void render(fill* t, ui_canvas* canvas, any* any, rectangle* r) {
  canvas->fill_rectangle(r, &t->color);
}

export [@ui_element]
struct frame {
  int width;
  color color;
};

export void render(frame* t, ui_canvas* canvas, any* any, rectangle* r) {
  canvas->frame_rectangle(r, &t->color, t->width);
}

export struct chain {
  vector<box<ui_element>> elems;
};

export box<ui_element>[] get_elems(chain* c) {
  return c->elems.slice();
}

export rectangle get_bounds(chain* c, int, ui_canvas*, rectangle* r) {
  return r->copy();
}

export struct margins {
  int width;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(margins* m) {
  return singleton_slice(&m->elem);
}

export rectangle get_bounds(margins* c, int, ui_canvas*, rectangle* r) {
  return r->plus_margin(-c->width);
}

export vec2 size(margins* t, ui_canvas* canvas) {
  return t->elem->size(canvas) + vec2(t->width, t->width) * 2;
}

export enum position_enum {
  CENTER,
  TOP_CENTER,
};

export struct position {
  position_enum pos;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(position* p) {
  return singleton_slice(&p->elem);
}

export rectangle get_bounds(position* p, int ind, ui_canvas* canvas, rectangle* r) {
  const size = p->elem->size(canvas);
  switch (p->pos) {
    case (CENTER) { return rectangle(r->middle() - size / 2, r->middle() + size / 2); }
    case (TOP_CENTER) { return rectangle(
        vec2(r->middle().x - size.x / 2, r->top()),
        vec2(r->middle().x + size.x / 2, r->top() + size.y)); }
  }
}

export [@ui_element]
struct vertical {
  vector<box<ui_element>> elems;
};

vector<rectangle> get_elem_positions(vertical* t, ui_canvas* canvas, rectangle* r) {
  mutable ret = vector<rectangle>();
  mutable start = 0;
  for (it : t->elems) {
    const height = it->get()->size(canvas).y;
    ret.push_back(rectangle(vec2(r->left(), r->top() + start),
        vec2(r->right(), r->top() + start + height)));
    start += height;
  }
  return move(ret);
}

export bool on_mouse_event(vertical* c, ui_canvas* canvas, any* data, rectangle* rect, mouse_event* event) {
  const positions = get_elem_positions(c, canvas, rect);
  for (it : c->elems)
    if (it->get()->on_mouse_event(canvas, data, &positions[it.index], event))
      return true;
  return false;
}

export void render(vertical* t, ui_canvas* canvas, any* any, rectangle* r) {
  const positions = get_elem_positions(t, canvas, r);
  for (it : t->elems)
    it->get()->render(canvas, any, &positions[it.index]);
}

export vec2 size(vertical* t, ui_canvas* canvas) {
  mutable ret = vec2(0, 0);
  for (it : t->elems) {
    const sz = it->get()->size(canvas);
    ret.y += sz.y;
    ret.x = max(ret.x, sz.x);
  }
  return ret;
}

export struct using_ui {
  string key;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(using_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(using_ui* c, int, ui_canvas*, rectangle* r) {
  return r->copy();
}

export any*!string transform_data(using_ui* u, any* a) {
  if (const r = a->cast_to<ui_record>()) {
    if (const res = (*r)->data.get_maybe(&u->key))
      return (*res)->get();
    return "{u->key}: record key not found in data.";
  } else
    return "Bad UI data: not a record: {a->get_type()}";
}

export struct width_ui {
  int width;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(width_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(width_ui* c, int, ui_canvas*, rectangle* r) {
  return r->copy();
}

export vec2 size(width_ui* t, ui_canvas* canvas) {
  return vec2(t->width, t->elem->size(canvas).y);
}

export struct height_ui {
  int height;
  box<ui_element> elem;
};

export box<ui_element>[] get_elems(height_ui* c) {
  return singleton_slice(&c->elem);
}

export rectangle get_bounds(height_ui* c, int, ui_canvas*, rectangle* r) {
  return r->copy();
}

export vec2 size(height_ui* t, ui_canvas* canvas) {
  return vec2(t->elem->size(canvas).x, t->height);
}

export [@ui_element]
struct key_handler {
  key_event event;
};

export bool on_key_event(key_handler* k, ui_canvas*, any* data, rectangle* rect, key_event* event) {
  if (*event == k->event)
    if (const callback = data->cast_to<box<ui_callback>>()) {
      (**callback)->invoke();
      return true;
    }
  return false;
}

