
export import "ui_canvas.znn";
import "rectangle.znn";
import "ui_event.znn";
import "game.znn";
export import "std/any.znn";
import "std/io.znn";
export import "ui.znn";
import "rectangle.znn";
import "field_of_view.znn";
import "ui_state.znn";
import "std/time.znn";

export [@ui_element]
struct GameLevelUI {
  int los;
  int tile_size;
  int font_size;
  int jumpDuration;
  double jumpHeight;
  double view_angle;
  double cameraSensitivity;
  key_event forward_key;
  key_event backward_key;
  key_event left_key;
  key_event right_key;
  key_event wait_key;
  key_event shoot_key;
};

export struct GameLevelUIData {
  Game mutable* game;
  invoke<void, int>* timeSpentCallback;
};

export bool onKeyEvent(GameLevelUI* ui, UIContext context, rectangle*, key_event* event) {
  const state = context.state->get_state<GameLevelUIState>();
  const data = *context.data->cast_to<GameLevelUIData>();
  if (*event == ui->forward_key)
    discard data->game->getPlayer()->advance(data->game, 4 * context.timeDiff, state->playerDir);
  else if (*event == ui->backward_key)
    discard data->game->getPlayer()->advance(data->game, -4 * context.timeDiff, state->playerDir);
  else if (*event == ui->left_key)
    discard data->game->getPlayer()->advance(data->game, 2 * context.timeDiff, state->playerDir + 1.57);
  else if (*event == ui->right_key)
    discard data->game->getPlayer()->advance(data->game, 2 * context.timeDiff, state->playerDir - 1.57);
  else if (*event == ui->shoot_key)
    shoot(context);
  else if (*event != ui->wait_key)
    return false;
  data->game->advance(context.timeDiff);
  return true;
}

vec2 projectOnScreen(GameLevelUI* ui, GameObject* player, vec2d pos, double playerDir) {
  const diff = pos - player->pos;
  const dist = ui->tile_size.as_double() * diff.length_d();
  const angle = playerDir - atan2(diff.x, diff.y);
  return vec2((sin(angle) * dist).as_int(), (-cos(angle) * dist * ui->view_angle).as_int());
}

export struct GameLevelUIState {
  double playerDir;
};

export GameLevelUIState() {
  return GameLevelUIState::GameLevelUIState(0.0);
}

void shoot(UIContext context) {
  const state = context.state->get_state<GameLevelUIState>();
  const data = *context.data->cast_to<GameLevelUIData>();
  data->game->spawnProjectile(data->game->getPlayer(), state->playerDir,
      Glyph(")", color(100, 100, 100), 0.7));
  data->timeSpentCallback->invoke(100);
}

export bool onMouseEvent(GameLevelUI* ui, UIContext context, rectangle*, mouse_event* event) {
  if (event->type == mouse_event_type::JOYSTICK_RIGHT) {
    context.state->get_state<GameLevelUIState>()->playerDir -=
        context.timeDiff * ui->cameraSensitivity * event->pos.x;
    const state = context.state->get_state<GameLevelUIState>();
    const data = *context.data->cast_to<GameLevelUIData>();
    if (event->pos.y != 0) {
      discard data->game->getPlayer()->advance(data->game, -4 * context.timeDiff * event->pos.y / 1000,
          state->playerDir);
      data->game->advance(context.timeDiff * abs(event->pos.y) / 1000);
    }
    return true;
  }
  if (event->type == mouse_event_type::LEFT) {
    shoot(context);
    return true;
  }
  return false;
}

double getJumpOffset(mutable double state) {
  if (state > 0.5)
    state -= 0.5;
  state *= 2;
  return 1.0 - (2.0 * state - 1) * (2.0 * state - 1);
}


export void render(GameLevelUI* ui, UIContext context, rectangle* r) {
  const data = *context.data->cast_to<GameLevelUIData>();
  const player = &data->game->objects[0];
  const pos_int = (player->pos + vec2d(0.5, 0.5)).as_int();
  const view_angle = 0.4;
  const origin = vec2(r->middle().x, (r->top() + 2 * r->bottom()) / 3);
  const to_draw = r->plus_margin(ui->tile_size);
  const state = context.state->get_state<GameLevelUIState>();
  mutable visibility = table<int>(vec2(ui->los, ui->los), 0);
  const get_obj_pos = [&](GameObject* obj) { return visibility.size() / 2 + obj->pos.as_int() - pos_int; };
  for (obj : data->game->objects)
    if (obj->attributes.blocksVision) {
      const opos = get_obj_pos(&*obj);
      if (visibility.bounds().contains(&opos))
        visibility[opos] = 1;
    }
  visibility = calculate_fov(&visibility, visibility.size() / 2, visibility.size().x / 2 - 1);
  for (pos : centered_rect(pos_int, ui->los))
    if (const t = data->game->level.getTile(*pos)) {
      const coord = origin + ui->projectOnScreen(player, pos->as_double(), state->playerDir);
      const vpos = *pos - pos_int + visibility.size() / 2;
      if (to_draw.contains(&coord) && visibility.bounds().contains(&vpos) && visibility[vpos] == 1)
        (*t)->glyph.render(context.canvas, ui->font_size, coord);
    }
  for (obj : data->game->objects) {
    const opos = get_obj_pos(&*obj);
    if (visibility.bounds().contains(&opos) && visibility[opos] == 1) {
      const coord = origin + ui->projectOnScreen(player, obj->pos, state->playerDir);
      if (to_draw.contains(&coord)) {
        const cur_time = current_time_milli();
        const offset = obj->lastMovement < cur_time - (1000 * context.timeDiff).as_int() - 10
            ? 0
            : (ui->font_size * ui->jumpHeight
                  * getJumpOffset((cur_time % ui->jumpDuration).as_double() / ui->jumpDuration)).as_int();
        obj->attributes.glyph.render(context.canvas, ui->font_size, coord - vec2(0, offset));
      }
    }
  }
}


