
export import "ui_canvas.znn";
import "rectangle.znn";
import "ui_event.znn";
import "game.znn";
export import "std/any.znn";
import "std/io.znn";
export import "ui.znn";
import "rectangle.znn";
import "field_of_view.znn";
import "ui_state.znn";

export [@ui_element]
struct game_level_ui {
  int los;
  int tile_size;
  int font_size;
  double view_angle;
  key_event forward_key;
  key_event backward_key;
  key_event left_key;
  key_event right_key;
  key_event wait_key;
};

export struct game_level_ui_data {
  game mutable* game;
  invoke<void, int>* time_spent_callback;
};

export bool on_key_event(game_level_ui* ui, ui_context context, rectangle*, key_event* event) {
  const state = context.state->get_state<game_level_ui_state>();
  const data = *context.data->cast_to<game_level_ui_data>();
  if (*event == ui->forward_key)
    discard data->game->get_player()->advance(data->game, 4 * context.time_diff, state->player_dir);
  else if (*event == ui->backward_key)
    discard data->game->get_player()->advance(data->game, -4 * context.time_diff, state->player_dir);
  else if (*event == ui->left_key)
    discard data->game->get_player()->advance(data->game, 2 * context.time_diff, state->player_dir + 1.57);
  else if (*event == ui->right_key)
    discard data->game->get_player()->advance(data->game, 2 * context.time_diff, state->player_dir - 1.57);
  else if (*event != ui->wait_key)
    return false;
  data->game->advance(context.time_diff);
  return true;
}

vec2 project_on_screen(game_level_ui* ui, game_object* player, vec2d pos, double player_dir) {
  const diff = pos - player->pos;
  const dist = ui->tile_size.as_double() * diff.length_d();
  const angle = player_dir - atan2(diff.x, diff.y);
  return vec2((sin(angle) * dist).as_int(), (-cos(angle) * dist * ui->view_angle).as_int());
}

struct screen_object_info {
  game_object* obj;
  vec2 coord;
};

export struct game_level_ui_state {
  double player_dir;
};

export game_level_ui_state() {
  return game_level_ui_state::game_level_ui_state(0.0);
}

export bool on_mouse_event(game_level_ui* ui, ui_context context, rectangle*, mouse_event* event) {
  if (event->type == mouse_event_type::RELATIVE_MOTION) {
    context.state->get_state<game_level_ui_state>()->player_dir -= 0.0008 * event->pos.x;
    return true;
  }
  if (event->type == mouse_event_type::LEFT) {
    const state = context.state->get_state<game_level_ui_state>();
    const data = *context.data->cast_to<game_level_ui_data>();
    data->game->spawn_projectile(data->game->get_player(), state->player_dir,
        glyph(')', color(100, 100, 100), 0.7));
    data->time_spent_callback->invoke(100);
    return true;
  }
  return false;
}

export void render(game_level_ui* ui, ui_context context, rectangle* r) {
  const data = *context.data->cast_to<game_level_ui_data>();
  context.canvas->fill_rectangle(r, &color(0, 0, 0));
  const player = &data->game->objects[0];
  const pos_int = (player->pos + vec2d(0.5, 0.5)).as_int();
  const view_angle = 0.4;
  const origin = vec2(r->middle().x, (r->top() + 2 * r->bottom()) / 3);
  const to_draw = r->plus_margin(ui->tile_size);
  const state = context.state->get_state<game_level_ui_state>();
  mutable visibility = table<int>(vec2(ui->los, ui->los), 0);
  const get_obj_pos = [&](game_object* obj) { return visibility.size() / 2 + obj->pos.as_int() - pos_int; };
  for (obj : data->game->objects)
    if (obj->blocksVision) {
      const opos = get_obj_pos(&*obj);
      if (visibility.bounds().contains(&opos))
        visibility[opos] = 1;
    }
  visibility = calculate_fov(&visibility, visibility.size() / 2, visibility.size().x / 2 - 1);
  for (pos : centered_rect(pos_int, ui->los))
    if (const t = data->game->level.get_tile(*pos)) {
      const coord = origin + ui->project_on_screen(player, pos->as_double(), state->player_dir);
      const vpos = *pos - pos_int + visibility.size() / 2;
      if (to_draw.contains(&coord) && visibility.bounds().contains(&vpos) && visibility[vpos] == 1)
        (*t)->glyph.render(context.canvas, ui->font_size, coord);
    }
  for (obj : data->game->objects) {
    const opos = get_obj_pos(&*obj);
    if (visibility.bounds().contains(&opos) && visibility[opos] == 1) {
      const coord = origin + ui->project_on_screen(player, obj->pos, state->player_dir);
      if (to_draw.contains(&coord))
        obj->glyph.render(context.canvas, ui->font_size, coord);
    }
  }
}


